well i'll be... the project compiled with the new files. now we need to plug in this functionality into main.htm in order to test it.

when i navigate to the main.htm, i see the following:

<description of what main.htm currently looks like>
It appears to be a dark-themed, in-game interface window titled Inertia (%name%) across the top. There are several tabs along the upper edge—Home, Favorite, Homepage, Region, Clan, Memo, Mail, and Friends—plus an Add Fav. button on the right. Below the title is a wide, rectangular section labeled Status, containing two buttons labeled Refresh and Reset. Underneath those buttons, there’s a line that says Time Left %time%.

Below Status is a box labeled Behavior with four rows. Each row has a label on the left (Auto Attack, Party Target, Movement, and More Options), a dropdown menu in the middle (showing placeholders like %attack%, %party%, %move%, %opt%), and on the right either a Set or Open button.

Further down, there is a heading labeled Targeting (with no apparent items directly under it) and, beneath that, another heading labeled Auto Skill. Under the Auto Skill heading are some numeric labels—e.g., “1 3 4 5”—likely representing skill slots or icons.

Overall, the interface looks like a control panel or settings window for a game, possibly letting the user adjust AI behavior (attack, targeting, movement) and other options, while showing remaining active time and allowing them to refresh or reset those settings.
</description of what main.htm looks like>

when i click on refresh i see "[17:46:06]  WARN Direct access to bypass: inertia_refresh %id% / Player: PacMan" in the game console logs.

when i click on reset i see "[17:46:08]  WARN Direct access to bypass: inertia_reset %id% / Player: PacMan"

clicking on the other buttons do not seem to do anything or generate game console logs.


<previous prompt>
okay, the following 5 files have been added to the bottom of the pile:
C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmEngine.java
C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmTask.java
C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmConfig.java
C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmState.java
C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmUIHandler.java

at this point in time, the main.htm file will need modifications too, feel free to keep it in alignment, as will i of it within the pile.
recall that i do already have a bypass, such that i can view main.htm in my dev server right now. we're just working with these 5 files to "bring it to life" as it were.

okay, attempting to compile as-is...

okay, our first compile errors are below. they include player.java. for these first cycles, lets see if we can resolve
with just the minimized player.java we have in the pile, since the full player.java is == the size of the total pile haha...

update: additionally, you bring up bypasshandler... i will add these files to the pile:
C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\BypassHandler.java
C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\IBypassHandler.java

<previous prompt, containing an updated pile>
okay, if thats the case, then now that we have made the necessary modifications for player.java and for world.java, our cycles are going to producing the actual autofarm code for our project.

please provide complete copy and pastable code products that are operable with the existing game server files that have been provided in the pile below.

note we're in a java 1.7 environment.

The 5 new files are placed here:
C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\
1. AutoFarmEngine.java
2. AutoFarmTask.java
3. AutoFarmConfig.java
4. AutoFarmState.java
5. AutoFarmUIHandler.java

main.htm from the “pile” is the entry point for this functionality. i already got that visible in my dev server. so be sure to glance at that early on in your process.
the inertia files are our reference files, recall they came from a similar autofarm project for a different game server code base. everything you ought to need, is in the pile.
check the list.

ill take what you produce and roll them into our pile, and then into our dev files, then we will attempt to compile the server. once compiled, we can begin to 
test and confirm functionalitity. below is all remaining project information:

im working hard to keep things organized for you. 

we have a completed pile. i expect you to have a very clear picture of the task at this point, so i expect more and more direction. 

<The Pile>
what you'll find below:
original prompt
plan for new files
Modifications Outside autofarm/ Directory
the pile list
pile files
<original prompt>
alright, i am able to access the main.htm page, its gonna be our guide to our mvp. note the environment is java 1.7.
main.htm has a status section, that needs a start button, but does have currently refresh and reset
then it has a behavior section, with the choices: auto attack - drop-down list - a 'set' button, then party attack, movement, more opts with their own drop downs and buttons.
then, a targeting section.
in my mind, i imagine if we can accumulate all game server files necessary for this functionality into one prompt, then we stand a decent shot at implementing this.

we can refer to this accumulation of game server files as the "pile".

i think we should start with player.java. it will be the largest file we have to deal with. if we can derive from it the needed methods, then we can create a minimized version
of it, which shows everything that it has, so like all its imports, but then we only include the methods it has that we'll need. then, ill make sure that file remains with us,
and we can continue to go file by file, and build the pile. you'll know how far we are or how many cycles we are in because the pile will be growing until it appears complete.
does this sound reasonable?

last cycle, you surfaced the below files as necessary files to deliver the MVP, which we are doing via the main.htm page that I can now access in my server:
InertiaController.java
Inertia.java
InertiaAct.java
PlayerExt.java
IInertiaBehave.java
EAutoAttack.java
EMoveType.java
ESearchType.java
EPanelOption.java
main.htm

these files will be placed in the pile as reference files.
</original prompt>
<plan for new files>
Below is our initial plan for how we will implement the five new AutoFarm files. We’ll outline each file’s core responsibilities, the key references they will need from our existing codebase (“The Pile”), and how they interrelate. This is a broad, high-level map before we begin writing any code.

1. AutoFarmEngine.java
Purpose

Central manager (singleton or static holder) that coordinates all AutoFarm logic for every player who is “auto-farming.”
Maintains a collection (e.g., Map<Integer, AutoFarmState>) for all active AutoFarm sessions.
Provides methods to start/stop auto-farm for a given player, handle periodic updates, and store or load configurations as needed.
References to Existing Files

Player.java (changes have been made, see minimized version in the pile):
We likely need to access a custom getAutoFarmState() or setAutoFarmState() once we add them.
We’ll rely on methods from Player to do actions like doAttack(...), or to check conditions like isAttackingNow(), isInParty(), etc.
Creature.java / NpcInstance.java / MonsterInstance.java:
We’ll consult these for target logic (e.g., verifying if a target is a monster, or is auto-attackable).
ThreadPoolManager:
We’ll want to schedule tasks and run repeated cycles (the engine could schedule the AutoFarmTask).
(Optionally) Inertia.java / InertiaAct.java:
Not mandatory, but we might reuse patterns from Inertia’s approach (like concurrency or hooking into the game’s main loops).
The design can stay simpler; we don’t necessarily need to do it exactly like Inertia unless desired.
Planned Steps

Maintain a global map of playerObjectId -> AutoFarmState.
Provide external methods:
startAutoFarm(Player)
stopAutoFarm(Player)
getAutoFarmState(playerObjectId)
Possibly schedule a recurring update with ThreadPoolManager that iterates all active AutoFarmStates and calls AutoFarmTask logic.
2. AutoFarmTask.java
Purpose

A runnable or repeated task invoked at intervals (for example, every 1 second) that updates each player’s AutoFarmState.
Manages checking the player’s environment, picking targets, running actions (attack, pick up, etc.).
References to Existing Files

AutoFarmState (our own new class) for accessing a player’s current auto-farm logic.
Player.java:
We’ll be calling methods like player.isDead(), player.getTarget(), player.doAttack(...), etc.
World.java:
Possibly for scanning nearby objects (though we can rely on player.getTarget() or the player’s known list).
CharacterAI or PlayableAI logic:
We won’t rewrite the AI, but we might reference how to interpret CtrlIntention or how the normal game loop handles “attack” flows.
Planned Steps

The AutoFarmEngine (or ThreadPoolManager directly) will create a recurring schedule of AutoFarmTask.run().
Each run:
Retrieve active AutoFarmStates.
For each, check if the player is valid (online, not dead, meets conditions).
Decide how to proceed: pick a new target, attack, move, etc.
Possibly do single “tick” logic similar to how InertiaAct.tick(...) works.
3. AutoFarmConfig.java
Purpose

Holds configuration logic, e.g. “max range for searching mobs,” “cooldowns,” “enableAutoFarm,” etc.
Potentially reads from a config file or uses in-memory defaults.
References to Existing Files

Typically none from “The Pile,” unless we want to do DB reads or advanced config from L2DatabaseFactory, but that’s optional.
We may parallel how Inertia read/wrote “credits” but can keep it simpler.
Planned Steps

Provide a load() method (if reading from an external file).
Provide static fields or get/set logic for AUTO_FARM_RANGE, AUTO_FARM_DELAY_MS, etc.
Make sure to have a fallback if config files are absent.
4. AutoFarmState.java
Purpose

Per-player state container. For instance:
Whether the feature is active
The current target monster ID
Timeout counters, logic for skill usage, or item pickups
Possibly a queue of “actions” or “scenes” in the farm logic
References to Existing Files

Player.java / Creature.java:
We might store references (like a Player reference or object ID).
Use player.getXYZ() for positions, or check if they’re in combat, etc.
Possibly Skill.java if we want to keep track of a skill ID to use on each cycle.
Possibly we replicate how Inertia.java keeps a user’s “auto-chill” logic—just on a smaller scale.
Planned Steps

Store fields like:
boolean active
long nextActionTime or long lastAttackTime
int currentTargetId
Provide methods:
updateState(): decides next action (maybe search a new target, or keep attacking the same target).
resetState(): stops auto-farming or reinitializes.
Link to AutoFarmEngine so we can fetch or remove it easily.
5. AutoFarmUIHandler.java
Purpose

This is the HTML logic that manages main.htm, bridging game server “bypass” calls to actual code.
For example, from main.htm we do bypass -h autofarm_start → it triggers AutoFarmUIHandler which calls AutoFarmEngine.startAutoFarm(player).
References to Existing Files

main.htm from the “pile” is our starting point. we took it from the inertia project and will build into it to help ground the project.
InertiaController.java uses the same pattern of handling bypass commands. We’ll do something similar, but simpler.
Player.java for getting the current user from the bypass context.
Planned Steps

Implement an interface similar to IBypassHandler or a custom approach that parses cmd.
For bypass autofarm_start → AutoFarmEngine.startAutoFarm(player).
For bypass autofarm_stop → AutoFarmEngine.stopAutoFarm(player).
Possibly a UI refresh or usage of NpcHtmlMessage to display status.
</plan for new files>

<Modifications Outside autofarm/ Directory>
Below are the minimal changes we have made thus far for the auto-farming system based on the plan:

1) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Player.java <--- updated minimized file provided in pile
Player.java – Added a field AutoFarmState _autoFarmState and two methods:
java
Copy code
public AutoFarmState getAutoFarmState()
public void setAutoFarmState(AutoFarmState state)

2) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\World.java <--- complete updated file now provided in pile, now a candidate for re-minimization
World.java – added a line that notifies the auto-farm engine when new objects/NPCs become visible.

these changes have been reflected in the files presented in the pile below.
</Modifications Outside autofarm/ Directory>
<The Pile List>
Pile Files:
1) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Creature.java (minimized)
2) C:\l2sq\Pac Project\Java\l2ft\gameserver\templates\StatsSet.java
3) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\instances\MonsterInstance.java (minimized)
4) C:\l2sq\Pac Project\Java\l2ft\loginserver\database\L2DatabaseFactory.java
5) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\World.java (full file)
6) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Player.java (minimized)
7) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Skill.java (minimized)
8) InertiaController.java
9) Inertia.java
10) InertiaAct.java
11) PlayerExt.java
12) IInertiaBehave.java
13) EAutoAttack.java
14) EMoveType.java
15) ESearchType.java
16) EPanelOption.java
17) C:\l2sq\Pac Project\build\dist-dev\gameserver\data\html\scripts\services\community\autofarm\main.htm
18) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\GameObject.java (minimized)
19) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Playable.java (minimized)
20) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Summon.java (minimized)
21) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Party.java (minimized)
22) C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\Formulas.java (minimized)
23) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcInventory.java (minimized)
24) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcWarehouse.java
25) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcFreight.java
26) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\actor\instances\player\ShortCutList.java
27) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\actor\instances\player\MacroList.java
28) C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CharacterAI.java
29) C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\PlayerAI.java
30) C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CtrlIntention.java
31) C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CtrlEvent.java
32) C:\l2sq\Pac Project\Java\l2ft\gameserver\utils\Log.java
33) C:\l2sq\Pac Project\Java\l2ft\gameserver\utils\ItemFunctions.java (minimized)
34) C:\l2sq\Pac Project\Java\l2ft\gameserver\templates\PlayerTemplate.java
35) C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\SystemMessage2.java
36) C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\ActionFail.java
37) C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\MyTargetSelected.java
38) C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\UserInfo.java
39) C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\ServerClose.java
40) C:\l2sq\Pac Project\Java\l2ft\gameserver\ThreadPoolManager.java
41) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\PlayerGroup.java
42) C:\l2sq\Pac Project\Java\l2ft\gameserver\dao\CharacterDAO.java
43) C:\l2sq\Pac Project\Java\l2ft\gameserver\dao\EffectsDAO.java
44) C:\l2sq\Pac Project\Java\l2ft\gameserver\tables\SkillTable.java
45) C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\effects\EffectTemplate.java
46) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\EffectList.java (minimized)
47) C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\funcs\Func.java
48) C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\funcs\FuncTemplate.java
49) C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\skillclasses\MDam.java
50) C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\skillclasses\PDam.java
51) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\entity\events\GlobalEvent.java (minimized)
52) C:\l2sq\Pac Project\Java\l2ft\gameserver\geodata\GeoEngine.java (minimized)
53) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\instances\NpcInstance.java (minimized)
54) C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\PlayableAI.java - 1000 lines and important
55) C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Effect.java (minimized)
56) C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmEngine.java
57) C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmTask.java
58) C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmConfig.java
59) C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmState.java
60) C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmUIHandler.java
61) C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\BypassHandler.java
62) C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\IBypassHandler.java


</the pile list>
<Pile Files>

<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Creature.java>
package l2ft.gameserver.model;

import l2ft.commons.threading.RunnableImpl;
import l2ft.commons.util.Rnd;
import l2ft.gameserver.Config;
import l2ft.gameserver.ThreadPoolManager;
import l2ft.gameserver.ai.CharacterAI;
import l2ft.gameserver.ai.CtrlEvent;
import l2ft.gameserver.ai.CtrlIntention;
import l2ft.gameserver.model.instances.MonsterInstance;
import l2ft.gameserver.model.instances.NpcInstance;
import l2ft.gameserver.model.items.ItemInstance;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.AutoAttackStart;
import l2ft.gameserver.network.l2.s2c.AutoAttackStop;
import l2ft.gameserver.network.l2.s2c.MagicSkillCanceled;
import l2ft.gameserver.network.l2.s2c.MagicSkillUse;
import l2ft.gameserver.network.l2.s2c.SystemMessage2;
import l2ft.gameserver.stats.Formulas;
import l2ft.gameserver.templates.CharTemplate;
import l2ft.gameserver.utils.Location;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.List;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Minimized abstract Creature class 
 * with most advanced logic removed.
 */
public abstract class Creature extends GameObject {
    private static final Logger _log = LoggerFactory.getLogger(Creature.class);

    // Basic concurrency flags
    protected AtomicBoolean isDead = new AtomicBoolean();
    protected AtomicBoolean isTeleporting = new AtomicBoolean();

    // Current HP/MP
    protected double _currentHp = 1;
    protected double _currentMp = 1;

    // Attack & cast timings
    protected long _attackEndTime;
    protected long _attackReuseEndTime;
    protected boolean _isAttackAborted;

    // Casting
    private long _castInterruptTime;
    private Skill _castingSkill;
    public Future<?> _skillTask;
    public Future<?> _skillLaunchedTask;

    // Movement
    public boolean isMoving;
    public boolean isFollow;
    private Future<?> _moveTask;

    // Stats
    private double _currentCp;

    // Basic references
    protected CharTemplate _template;
    protected CharacterAI _ai;

    // Basic constructor
    public Creature(int objectId, CharTemplate template) {
        super(objectId);
        _template = template;
    }

    /** Returns this creature's AI. */
    public CharacterAI getAI() {
        if (_ai == null) {
            _ai = new CharacterAI(this);
        }
        return _ai;
    }

    @Override
    public boolean isCreature() {
        return true;
    }

    /** Is this creature currently dead? */
    public final boolean isDead() {
        return isDead.get();
    }

    /** Health-related. */
    public double getCurrentHp() {
        return _currentHp;
    }
    public double getCurrentMp() {
        return _currentMp;
    }
    public void setCurrentHp(double newHp) {
        _currentHp = Math.max(0, newHp);
        if (_currentHp < 0.5 && !isDead.get()) {
            doDie(null);
        }
    }
    public void setCurrentMp(double newMp) {
        _currentMp = Math.max(0, newMp);
    }

    /** Called when HP drops below 1. */
    public void doDie(Creature killer) {
        if (!isDead.compareAndSet(false, true))
            return;
        onDeath(killer);
    }

    protected void onDeath(Creature killer) {
        setTarget(null);
        stopMove();
        _currentHp = 0;
        getAI().notifyEvent(CtrlEvent.EVT_DEAD, killer, null);
    }

    /** Aborts attack/cast if needed, sets intention active, broadcast. */
    public void abortAttack(boolean force, boolean message) {
        if (isAttackingNow()) {
            _attackEndTime = 0;
            _isAttackAborted = true;
            getAI().setIntention(CtrlIntention.AI_INTENTION_ACTIVE);
            if (isPlayer() && message)
                sendPacket(SystemMsg.C1S_ATTACK_FAILED);
        }
    }

    public void abortCast(boolean force, boolean message) {
        if (isCastingNow() && (force || canAbortCast())) {
            clearCastVars();
            getAI().setIntention(CtrlIntention.AI_INTENTION_ACTIVE);
            if (isPlayer() && message)
                sendPacket(SystemMsg.YOUR_CASTING_HAS_BEEN_INTERRUPTED);
        }
    }

    public boolean canAbortCast() {
        return _castInterruptTime > System.currentTimeMillis();
    }

    /** Attack logic (hugely simplified). */
    public void doAttack(Creature target) {
        if (target == null || isAlikeDead() || target.isAlikeDead())
            return;

        // Basic attack interval
        int sAtk = 400; 
        _attackEndTime = System.currentTimeMillis() + sAtk;
        _isAttackAborted = false;

        onHitTimer(target, 100, false, false, false, false, true, true); 
    }

    /** Actually deals damage to the target on the right moment. */
    public void onHitTimer(Creature target, int damage, boolean crit, boolean miss, 
                           boolean soulshot, boolean shld, boolean unchargeSS, boolean notify) {
        if (isAlikeDead() || target.isDead())
            return;
        target.reduceCurrentHp(damage, this, null, true, true, false, false, false, false, true);
        startAttackStanceTask();
    }

    /** Called to reduce current HP, applying typical "damage" logic. */
    public void reduceCurrentHp(double damage, Creature attacker, Skill skill, 
                                boolean awake, boolean standUp, boolean directHp,
                                boolean canReflect, boolean transferDamage, 
                                boolean isDot, boolean sendMessage) {
        if (isDead())
            return;
        setCurrentHp(getCurrentHp() - damage);
    }

    /** Simple stance logic. */
    public void startAttackStanceTask() {
        broadcastPacket(new AutoAttackStart(getObjectId()));
    }
    public void stopAttackStanceTask() {
        broadcastPacket(new AutoAttackStop(getObjectId()));
    }

    /** Movement. */
    public void moveToLocation(int x, int y, int z, int offset) {
        isMoving = true;
        // Omitted: geodata checks, path building
    }
    public void followToCharacter(Creature target, int offset, boolean forestalling) {
        isFollow = true;
        // Omitted: full path logic
    }
    public void stopMove() {
        isMoving = false;
        isFollow = false;
        if (_moveTask != null) {
            _moveTask.cancel(false);
            _moveTask = null;
        }
    }

    /** Casting. */
    public boolean isCastingNow() {
        return _skillTask != null;
    }
    public boolean isAttackingNow() {
        return _attackEndTime > System.currentTimeMillis();
    }
    public void clearCastVars() {
        _castInterruptTime = 0;
        _castingSkill = null;
        if (_skillTask != null) {
            _skillTask.cancel(false);
            _skillTask = null;
        }
        if (_skillLaunchedTask != null) {
            _skillLaunchedTask.cancel(false);
            _skillLaunchedTask = null;
        }
    }

    public boolean isAlikeDead() {
        return isDead() || isFakeDeath();
    }
    public boolean isFakeDeath() { return false; }

    @Override
    public String toString() {
        return getClass().getSimpleName()+"["+getObjectId()+"]";
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Creature.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\templates\StatsSet.java>
package l2ft.gameserver.templates;

import l2ft.commons.collections.MultiValueSet;

public class StatsSet extends MultiValueSet<String>
{
	private static final long serialVersionUID = -2209589233655930756L;
	@SuppressWarnings("serial")
	public static final StatsSet EMPTY = new StatsSet()
	{
		@Override
		public Object put(String a, Object a2)
		{
			throw new UnsupportedOperationException();
		}
	};

	public StatsSet()
	{
		super();
	}

	public StatsSet(StatsSet set)
	{
		super(set);
	}

	@Override
	public StatsSet clone()
	{
		return new StatsSet(this);
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\templates\StatsSet.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\instances\MonsterInstance.java>
package l2ft.gameserver.model.instances;

import l2ft.gameserver.ai.CtrlEvent;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.model.base.Experience;
import l2ft.gameserver.model.base.TeamType;
import l2ft.gameserver.model.entity.Reflection;
import l2ft.gameserver.model.quest.Quest;
import l2ft.gameserver.network.l2.s2c.SystemMessage;
import l2ft.gameserver.templates.npc.NpcTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized MonsterInstance class
 * removing minion/raid logic and advanced drops/quests.
 */
public class MonsterInstance extends NpcInstance {
    private static final Logger _log = LoggerFactory.getLogger(MonsterInstance.class);

    // Over-hit system
    private double _overhitDamage;
    private int _overhitAttackerId;

    // Champion
    private int _isChampion;

    public MonsterInstance(int objectId, NpcTemplate template) {
        super(objectId, template);
    }

    // Basic champion setting
    public void setChampion(int level) {
        _isChampion = level; // 0 = none, 1+ = champion
    }
    public int getChampion() {
        return _isChampion;
    }

    @Override
    protected void onDeath(Creature killer) {
        // Basic drop/sp logic is removed or greatly simplified
        super.onDeath(killer);
    }

    @Override
    public boolean isAutoAttackable(Creature attacker) {
        return !attacker.isMonster();
    }

    // Over-hit
    public void setOverhitAttacker(Creature attacker) {
        _overhitAttackerId = (attacker == null ? 0 : attacker.getObjectId());
    }
    public void setOverhitDamage(double damage) {
        _overhitDamage = damage;
    }
    public double getOverhitDamage() {
        return _overhitDamage;
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\instances\MonsterInstance.java>
<C:\l2sq\Pac Project\Java\l2ft\loginserver\database\L2DatabaseFactory.java>
// java/l2ft/loginserver/database/L2DatabaseFactory.java
package l2ft.loginserver.database;

import java.sql.Connection;
import java.sql.SQLException;

import l2ft.loginserver.Config;
import l2ft.commons.dbcp.BasicDataSource;


public class L2DatabaseFactory extends BasicDataSource
{
	private static final L2DatabaseFactory _instance = new L2DatabaseFactory();
	public static final L2DatabaseFactory getInstance()
	{
		return _instance;
	}

	public L2DatabaseFactory()
	{
		super(Config.DATABASE_DRIVER, Config.DATABASE_URL, Config.DATABASE_LOGIN, Config.DATABASE_PASSWORD, Config.DATABASE_MAX_CONNECTIONS, Config.DATABASE_MAX_CONNECTIONS, Config.DATABASE_MAX_IDLE_TIMEOUT, Config.DATABASE_IDLE_TEST_PERIOD, false);
	}

	@Override
	public Connection getConnection() throws SQLException
	{
		return getConnection(null);
	}
}
// EOF java/l2ft/loginserver/database/L2DatabaseFactory.java

</C:\l2sq\Pac Project\Java\l2ft\loginserver\database\L2DatabaseFactory.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\World.java>
// java/l2ft/gameserver/model/World.java
package l2ft.gameserver.model;

import java.util.Collections;
import java.util.List;

import l2ft.commons.collections.LazyArrayList;
import l2ft.gameserver.Config;
import l2ft.gameserver.model.Zone.ZoneType;
import l2ft.gameserver.model.entity.Reflection;
import l2ft.gameserver.model.instances.NpcInstance;
import l2ft.gameserver.network.l2.s2c.L2GameServerPacket;
import l2ft.gameserver.utils.Location;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Переработанный класс мира
 * Original code + minor auto-farm hook in addVisibleObject(...)
 */
public class World {
	private static final Logger _log = LoggerFactory.getLogger(World.class);

	/** Map dimensions */
	public static final int MAP_MIN_X = Config.GEO_X_FIRST - 20 << 15;
	public static final int MAP_MAX_X = (Config.GEO_X_LAST - 20 + 1 << 15) - 1;
	public static final int MAP_MIN_Y = Config.GEO_Y_FIRST - 18 << 15;
	public static final int MAP_MAX_Y = (Config.GEO_Y_LAST - 18 + 1 << 15) - 1;
	public static final int MAP_MIN_Z = Config.MAP_MIN_Z;
	public static final int MAP_MAX_Z = Config.MAP_MAX_Z;

	public static final int WORLD_SIZE_X = Config.GEO_X_LAST - Config.GEO_X_FIRST + 1;
	public static final int WORLD_SIZE_Y = Config.GEO_Y_LAST - Config.GEO_Y_FIRST + 1;

	public static final int SHIFT_BY = Config.SHIFT_BY;
	public static final int SHIFT_BY_Z = Config.SHIFT_BY_Z;

	/** calculated offset used so top left region is 0,0 */
	public static final int OFFSET_X = Math.abs(MAP_MIN_X >> SHIFT_BY);
	public static final int OFFSET_Y = Math.abs(MAP_MIN_Y >> SHIFT_BY);
	public static final int OFFSET_Z = Math.abs(MAP_MIN_Z >> SHIFT_BY_Z);

	/** Размерность массива регионов */
	private static final int REGIONS_X = (MAP_MAX_X >> SHIFT_BY) + OFFSET_X;
	private static final int REGIONS_Y = (MAP_MAX_Y >> SHIFT_BY) + OFFSET_Y;
	private static final int REGIONS_Z = (MAP_MAX_Z >> SHIFT_BY_Z) + OFFSET_Z;

	private static volatile WorldRegion[][][] _worldRegions = new WorldRegion[REGIONS_X + 1][REGIONS_Y + 1][REGIONS_Z
			+ 1];

	public static void init() {
		_log.info("L2World: Creating regions: ["
				+ (REGIONS_X + 1) + "]["
				+ (REGIONS_Y + 1) + "]["
				+ (REGIONS_Z + 1) + "].");
	}

	private static WorldRegion[][][] getRegions() {
		return _worldRegions;
	}

	private static int validX(int x) {
		if (x < 0)
			x = 0;
		else if (x > REGIONS_X)
			x = REGIONS_X;
		return x;
	}

	private static int validY(int y) {
		if (y < 0)
			y = 0;
		else if (y > REGIONS_Y)
			y = REGIONS_Y;
		return y;
	}

	private static int validZ(int z) {
		if (z < 0)
			z = 0;
		else if (z > REGIONS_Z)
			z = REGIONS_Z;
		return z;
	}

	public static int validCoordX(int x) {
		if (x < MAP_MIN_X)
			x = MAP_MIN_X + 1;
		else if (x > MAP_MAX_X)
			x = MAP_MAX_X - 1;
		return x;
	}

	public static int validCoordY(int y) {
		if (y < MAP_MIN_Y)
			y = MAP_MIN_Y + 1;
		else if (y > MAP_MAX_Y)
			y = MAP_MAX_Y - 1;
		return y;
	}

	public static int validCoordZ(int z) {
		if (z < MAP_MIN_Z)
			z = MAP_MIN_Z + 1;
		else if (z > MAP_MAX_Z)
			z = MAP_MAX_Z - 1;
		return z;
	}

	private static int regionX(int x) {
		return (x >> SHIFT_BY) + OFFSET_X;
	}

	private static int regionY(int y) {
		return (y >> SHIFT_BY) + OFFSET_Y;
	}

	private static int regionZ(int z) {
		return (z >> SHIFT_BY_Z) + OFFSET_Z;
	}

	static boolean isNeighbour(int x1, int y1, int z1, int x2, int y2, int z2) {
		return x1 <= x2 + 1 && x1 >= x2 - 1
				&& y1 <= y2 + 1 && y1 >= y2 - 1
				&& z1 <= z2 + 1 && z1 >= z2 - 1;
	}

	/**
	 * Returns the WorldRegion for the given location.
	 */
	public static WorldRegion getRegion(Location loc) {
		return getRegion(
				validX(regionX(loc.x)),
				validY(regionY(loc.y)),
				validZ(regionZ(loc.z)));
	}

	/**
	 * Returns the WorldRegion for the given GameObject.
	 */
	public static WorldRegion getRegion(GameObject obj) {
		return getRegion(
				validX(regionX(obj.getX())),
				validY(regionY(obj.getY())),
				validZ(regionZ(obj.getZ())));
	}

	/**
	 * Returns the WorldRegion instance for the given region indexes.
	 */
	private static WorldRegion getRegion(int x, int y, int z) {
		WorldRegion[][][] regions = getRegions();
		WorldRegion region = regions[x][y][z];
		if (region == null) {
			synchronized (regions) {
				region = regions[x][y][z];
				if (region == null)
					region = regions[x][y][z] = new WorldRegion(x, y, z);
			}
		}
		return region;
	}

	public static Player getPlayer(String name) {
		return GameObjectsStorage.getPlayer(name);
	}

	public static Player getPlayer(int objId) {
		return GameObjectsStorage.getPlayer(objId);
	}

	/**
	 * Checks if the object's region changed. If so, remove from old region and add
	 * to new.
	 */
	public static void addVisibleObject(GameObject object, Creature dropper) {
		if (object == null || !object.isVisible() || object.isInObserverMode())
			return;

		WorldRegion region = getRegion(object);
		WorldRegion currentRegion = object.getCurrentRegion();

		if (currentRegion == region)
			return;

		if (currentRegion == null) {
			// A new object entering the world
			object.setCurrentRegion(region);
			region.addObject(object);

			// Optional: Hook for auto-farm engine if needed
			// try {
			// AutoFarmEngine.getInstance().onObjectAdded(object);
			// } catch(Exception e) {
			// // handle error
			// }

			// Show object in current + neighboring regions
			for (int x = validX(region.getX() - 1); x <= validX(region.getX() + 1); x++)
				for (int y = validY(region.getY() - 1); y <= validY(region.getY() + 1); y++)
					for (int z = validZ(region.getZ() - 1); z <= validZ(region.getZ() + 1); z++)
						getRegion(x, y, z).addToPlayers(object, dropper);
		} else {
			// Object moved from one region to another
			currentRegion.removeObject(object);
			object.setCurrentRegion(region);
			region.addObject(object);

			for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
				for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
					for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
						if (!isNeighbour(region.getX(), region.getY(), region.getZ(), x, y, z))
							getRegion(x, y, z).removeFromPlayers(object);

			for (int x = validX(region.getX() - 1); x <= validX(region.getX() + 1); x++)
				for (int y = validY(region.getY() - 1); y <= validY(region.getY() + 1); y++)
					for (int z = validZ(region.getZ() - 1); z <= validZ(region.getZ() + 1); z++)
						if (!isNeighbour(currentRegion.getX(), currentRegion.getY(), currentRegion.getZ(), x, y, z))
							getRegion(x, y, z).addToPlayers(object, dropper);
		}
	}

	public static void removeVisibleObject(GameObject object) {
		if (object == null || object.isVisible() || object.isInObserverMode())
			return;

		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return;

		object.setCurrentRegion(null);
		currentRegion.removeObject(object);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					getRegion(x, y, z).removeFromPlayers(object);
	}

	public static GameObject getAroundObjectById(GameObject object, int objId) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return null;

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z))
						if (obj.getObjectId() == objId)
							return obj;

		return null;
	}

	public static List<GameObject> getAroundObjects(GameObject object) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();

		List<GameObject> result = new LazyArrayList<>(128);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						result.add(obj);
					}
		return result;
	}

	public static List<GameObject> getAroundObjects(GameObject object, int radius, int height) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();
		int ox = object.getX();
		int oy = object.getY();
		int oz = object.getZ();
		int sqrad = radius * radius;

		List<GameObject> result = new LazyArrayList<>(128);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						if (Math.abs(obj.getZ() - oz) > height)
							continue;
						int dx = Math.abs(obj.getX() - ox);
						if (dx > radius)
							continue;
						int dy = Math.abs(obj.getY() - oy);
						if (dy > radius)
							continue;
						if ((dx * dx + dy * dy) > sqrad)
							continue;
						result.add(obj);
					}
		return result;
	}

	public static List<Creature> getAroundCharacters(GameObject object) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();

		List<Creature> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isCreature() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						result.add((Creature) obj);
					}
		return result;
	}

	public static List<Creature> getAroundCharacters(GameObject object, int radius, int height) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();
		int ox = object.getX();
		int oy = object.getY();
		int oz = object.getZ();
		int sqrad = radius * radius;

		List<Creature> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isCreature() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						if (Math.abs(obj.getZ() - oz) > height)
							continue;
						int dx = Math.abs(obj.getX() - ox);
						if (dx > radius)
							continue;
						int dy = Math.abs(obj.getY() - oy);
						if (dy > radius)
							continue;
						if ((dx * dx + dy * dy) > sqrad)
							continue;
						result.add((Creature) obj);
					}
		return result;
	}

	public static List<NpcInstance> getAroundNpc(GameObject object) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();

		List<NpcInstance> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isNpc() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						result.add((NpcInstance) obj);
					}
		return result;
	}

	public static List<NpcInstance> getAroundNpc(GameObject object, int radius, int height) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();
		int ox = object.getX();
		int oy = object.getY();
		int oz = object.getZ();
		int sqrad = radius * radius;

		List<NpcInstance> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isNpc() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						if (Math.abs(obj.getZ() - oz) > height)
							continue;
						int dx = Math.abs(obj.getX() - ox);
						if (dx > radius)
							continue;
						int dy = Math.abs(obj.getY() - oy);
						if (dy > radius)
							continue;
						if ((dx * dx + dy * dy) > sqrad)
							continue;
						result.add((NpcInstance) obj);
					}
		return result;
	}

	public static List<Playable> getAroundPlayables(GameObject object) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();

		List<Playable> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++) {
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isPlayable() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						result.add((Playable) obj);
					}
				}
		return result;
	}

	public static List<Playable> getAroundPlayables(GameObject object, int radius, int height) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();
		int ox = object.getX();
		int oy = object.getY();
		int oz = object.getZ();
		int sqrad = radius * radius;

		List<Playable> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++) {
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isPlayable() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						if (Math.abs(obj.getZ() - oz) > height)
							continue;
						int dx = Math.abs(obj.getX() - ox);
						if (dx > radius)
							continue;
						int dy = Math.abs(obj.getY() - oy);
						if (dy > radius)
							continue;
						if ((dx * dx + dy * dy) > sqrad)
							continue;
						result.add((Playable) obj);
					}
				}
		return result;
	}

	public static List<Player> getAroundPlayers(GameObject object) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();

		List<Player> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isPlayer() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						result.add((Player) obj);
					}
		return result;
	}

	public static List<Player> getAroundPlayers(GameObject object, int radius, int height) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return Collections.emptyList();

		int oid = object.getObjectId();
		int rid = object.getReflectionId();
		int ox = object.getX();
		int oy = object.getY();
		int oz = object.getZ();
		int sqrad = radius * radius;

		List<Player> result = new LazyArrayList<>(64);

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++) {
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isPlayer() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						if (Math.abs(obj.getZ() - oz) > height)
							continue;
						int dx = Math.abs(obj.getX() - ox);
						if (dx > radius)
							continue;
						int dy = Math.abs(obj.getY() - oy);
						if (dy > radius)
							continue;
						if ((dx * dx + dy * dy) > sqrad)
							continue;
						result.add((Player) obj);
					}
				}
		return result;
	}

	/**
	 * Check if neighbors (including the current region) are empty of players
	 */
	public static boolean isNeighborsEmpty(WorldRegion region) {
		for (int x = validX(region.getX() - 1); x <= validX(region.getX() + 1); x++)
			for (int y = validY(region.getY() - 1); y <= validY(region.getY() + 1); y++)
				for (int z = validZ(region.getZ() - 1); z <= validZ(region.getZ() + 1); z++)
					if (!getRegion(x, y, z).isEmpty())
						return false;
		return true;
	}

	public static void activate(WorldRegion currentRegion) {
		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					getRegion(x, y, z).setActive(true);
	}

	public static void deactivate(WorldRegion currentRegion) {
		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() + 1); y >= validY(currentRegion.getY() - 1); y--)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					if (isNeighborsEmpty(getRegion(x, y, z)))
						getRegion(x, y, z).setActive(false);
	}

	/**
	 * Shows all visible objects in current and neighboring regions to the specified
	 * player.
	 */
	public static void showObjectsToPlayer(Player player) {
		WorldRegion currentRegion = player.isInObserverMode() ? player.getObserverRegion() : player.getCurrentRegion();
		if (currentRegion == null)
			return;

		int oid = player.getObjectId();
		int rid = player.getReflectionId();

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++) {
					for (GameObject obj : getRegion(x, y, z)) {
						if (obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						player.sendPacket(player.addVisibleObject(obj, null));
					}
				}
	}

	/**
	 * Removes all visible objects from the specified player in current and
	 * neighboring regions.
	 */
	public static void removeObjectsFromPlayer(Player player) {
		WorldRegion currentRegion = player.isInObserverMode() ? player.getObserverRegion() : player.getCurrentRegion();
		if (currentRegion == null)
			return;

		int oid = player.getObjectId();
		int rid = player.getReflectionId();

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++) {
					for (GameObject obj : getRegion(x, y, z)) {
						if (obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;
						player.sendPacket(player.removeVisibleObject(obj, null));
					}
				}
	}

	/**
	 * Removes the specified object from all players in the region.
	 */
	public static void removeObjectFromPlayers(GameObject object) {
		WorldRegion currentRegion = object.getCurrentRegion();
		if (currentRegion == null)
			return;

		int oid = object.getObjectId();
		int rid = object.getReflectionId();

		Player p;
		List<L2GameServerPacket> d = null;

		for (int x = validX(currentRegion.getX() - 1); x <= validX(currentRegion.getX() + 1); x++)
			for (int y = validY(currentRegion.getY() - 1); y <= validY(currentRegion.getY() + 1); y++)
				for (int z = validZ(currentRegion.getZ() - 1); z <= validZ(currentRegion.getZ() + 1); z++)
					for (GameObject obj : getRegion(x, y, z)) {
						if (!obj.isPlayer() || obj.getObjectId() == oid || obj.getReflectionId() != rid)
							continue;

						p = (Player) obj;
						p.sendPacket(p.removeVisibleObject(object, d == null ? d = object.deletePacketList() : d));
					}
	}

	static void addZone(Zone zone) {
		Reflection reflection = zone.getReflection();

		Territory territory = zone.getTerritory();
		if (territory == null) {
			_log.info("World: zone - " + zone.getName() + " not has territory.");
			return;
		}
		// FIX: Replaced region.getYmax() with territory.getYmax(), and removed the
		// extra semicolon
		for (int x = validX(regionX(territory.getXmin())); x <= validX(regionX(territory.getXmax())); x++)
			for (int y = validY(regionY(territory.getYmin())); y <= validY(regionY(territory.getYmax())); y++)
				for (int z = validZ(regionZ(territory.getZmin())); z <= validZ(regionZ(territory.getZmax())); z++) {
					WorldRegion region = getRegion(x, y, z);
					region.addZone(zone);
					for (GameObject obj : region) {
						if (!obj.isCreature() || obj.getReflection() != reflection)
							continue;
						((Creature) obj).updateZones();
					}
				}
	}

	static void removeZone(Zone zone) {
		Reflection reflection = zone.getReflection();

		Territory territory = zone.getTerritory();
		if (territory == null) {
			_log.info("World: zone - " + zone.getName() + " not has territory.");
			return;
		}
		// FIX: Replaced region.getYmax() with territory.getYmax(), and removed the
		// extra semicolon
		for (int x = validX(regionX(territory.getXmin())); x <= validX(regionX(territory.getXmax())); x++)
			for (int y = validY(regionY(territory.getYmin())); y <= validY(regionY(territory.getYmax())); y++)
				for (int z = validZ(regionZ(territory.getZmin())); z <= validZ(regionZ(territory.getZmax())); z++) {
					WorldRegion region = getRegion(x, y, z);
					region.removeZone(zone);
					for (GameObject obj : region) {
						if (!obj.isCreature() || obj.getReflection() != reflection)
							continue;
						((Creature) obj).updateZones();
					}
				}
	}

	/**
	 * Creates and returns a list of zones for x, y, z.
	 */
	public static void getZones(List<Zone> inside, Location loc, Reflection reflection) {
		WorldRegion region = getRegion(loc);
		Zone[] zones = region.getZones();
		if (zones.length == 0)
			return;
		for (Zone zone : zones)
			if (zone.checkIfInZone(loc.x, loc.y, loc.z, reflection))
				inside.add(zone);
	}

	public static boolean isWater(Location loc, Reflection reflection) {
		return getWater(loc, reflection) != null;
	}

	public static Zone getWater(Location loc, Reflection reflection) {
		WorldRegion region = getRegion(loc);
		Zone[] zones = region.getZones();
		if (zones.length == 0)
			return null;
		for (Zone zone : zones)
			if (zone != null
					&& zone.getType() == ZoneType.water
					&& zone.checkIfInZone(loc.x, loc.y, loc.z, reflection))
				return zone;
		return null;
	}

	/**
	 * Returns stats about regions
	 * 
	 * @return int[] where:
	 *         [0] count of total regions visited,
	 *         [1] count active,
	 *         [2] count inactive,
	 *         [3] count uninitialized,
	 *         [10] total objects,
	 *         [11] total creatures,
	 *         [12] total players,
	 *         [13] offline players,
	 *         [14] NPCs,
	 *         [15] active NPCs,
	 *         [16] monsters,
	 *         [17] minions,
	 *         [18] summons/pets,
	 *         [19] doors,
	 *         [20] items
	 */
	public static int[] getStats() {
		WorldRegion region;
		int[] ret = new int[32];

		for (int x = 0; x <= REGIONS_X; x++) {
			for (int y = 0; y <= REGIONS_Y; y++) {
				for (int z = 0; z <= REGIONS_Z; z++) {
					ret[0]++;
					region = _worldRegions[x][y][z];

					if (region != null) {
						if (region.isActive())
							ret[1]++;
						else
							ret[2]++;

						for (GameObject obj : region) {
							ret[10]++;
							if (obj.isCreature()) {
								ret[11]++;
								if (obj.isPlayer()) {
									ret[12]++;
									Player p = (Player) obj;
									if (p.isInOfflineMode())
										ret[13]++;
								} else if (obj.isNpc()) {
									ret[14]++;
									if (obj.isMonster()) {
										ret[16]++;
										if (obj.isMinion())
											ret[17]++;
									}
									NpcInstance npc = (NpcInstance) obj;
									if (npc.hasAI() && npc.getAI().isActive())
										ret[15]++;
								} else if (obj.isPlayable())
									ret[18]++;
								else if (obj.isDoor())
									ret[19]++;
							} else if (obj.isItem())
								ret[20]++;
						}
					} else
						ret[3]++;
				}
			}
		}
		return ret;
	}
}
// EOF java/l2ft/gameserver/model/World.java

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\World.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Player.java>
// ============================================================================
// ========================= MINIMIZED Player.java =============================
// ============================================================================
package l2ft.gameserver.model;

import static l2ft.gameserver.network.l2.s2c.ExSetCompassZoneCode.*;

import java.awt.Color;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
// ... many more imports omitted in this snippet ...
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import l2ft.commons.collections.LazyArrayList;
import l2ft.commons.dao.JdbcEntityState;
import l2ft.commons.dbutils.DbUtils;
import l2ft.commons.lang.reference.HardReference;
import l2ft.commons.lang.reference.HardReferences;
import l2ft.commons.threading.RunnableImpl;
import l2ft.commons.util.Rnd;
import l2ft.gameserver.Config;
import l2ft.gameserver.GameTimeController;
import l2ft.gameserver.ThreadPoolManager;
import l2ft.gameserver.ai.CtrlEvent;
import l2ft.gameserver.ai.CtrlIntention;
import l2ft.gameserver.ai.PlayableAI.nextAction;
import l2ft.gameserver.ai.PlayerAI;
import l2ft.gameserver.cache.Msg;
import l2ft.gameserver.dao.AccountBonusDAO;
import l2ft.gameserver.dao.CharacterDAO;
import l2ft.gameserver.dao.CharacterGroupReuseDAO;
import l2ft.gameserver.dao.CharacterPostFriendDAO;
import l2ft.gameserver.dao.EffectsDAO;
import l2ft.gameserver.autofarm.AutoFarmState;
// ... more DAO / manager imports ...
import l2ft.gameserver.network.authcomm.AuthServerCommunication;
import l2ft.gameserver.network.authcomm.gspackets.ChangeAccessLevel;
import l2ft.gameserver.network.l2.GameClient;
import l2ft.gameserver.network.l2.components.CustomMessage;
import l2ft.gameserver.network.l2.components.IStaticPacket;
import l2ft.gameserver.network.l2.components.SceneMovie;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.ActionFail;
import l2ft.gameserver.network.l2.s2c.CharInfo;
import l2ft.gameserver.network.l2.s2c.ConfirmDlg;
import l2ft.gameserver.network.l2.s2c.GetItem;
import l2ft.gameserver.network.l2.s2c.InventoryUpdate;
import l2ft.gameserver.network.l2.s2c.ItemList;
import l2ft.gameserver.network.l2.s2c.MyTargetSelected;
import l2ft.gameserver.network.l2.s2c.NpcInfoPoly;
import l2ft.gameserver.network.l2.s2c.ServerClose;
import l2ft.gameserver.network.l2.s2c.SystemMessage;
import l2ft.gameserver.network.l2.s2c.SystemMessage2;
import l2ft.gameserver.network.l2.s2c.TeleportToLocation;
import l2ft.gameserver.network.l2.s2c.UserInfo;
// ... skill / stats imports ...
import l2ft.gameserver.skills.EffectType;
import l2ft.gameserver.skills.TimeStamp;
import l2ft.gameserver.stats.Formulas;
import l2ft.gameserver.stats.Stats;
import l2ft.gameserver.stats.funcs.FuncTemplate;
import l2ft.gameserver.tables.ClanTable;
import l2ft.gameserver.utils.*;
// ... many others ...
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized version of the Player class.
 * Retains all imports, keeps only a smaller subset of fields & methods 
 * that are commonly relevant for basic MVP functions (attack, move, pickup, etc.).
 */
public final class Player extends Playable implements PlayerGroup
{
    private static final Logger _log = LoggerFactory.getLogger(Player.class);

    // ============= Basic Constants =============
    public static final int DEFAULT_TITLE_COLOR = 0xFFFF77;
    public static final int STORE_PRIVATE_NONE = 0;
	private AutoFarmState _autoFarmState;
    // ... many other static fields removed ...

    // ============= Basic Fields (kept short) =============
    private GameClient _connection;
    private String _login;
    private int _karma;
    private int _pkKills, _pvpKills;
    // Player's store status
    private int _privatestore;
    // Summon
    private Summon _summon = null;

    // Basic player's party
    private Party _party;

    // Basic references
    private AtomicBoolean _isLogout = new AtomicBoolean();
    private boolean _isOnline = false;
    private boolean _offline = false;

    private boolean _isSitting;

    // Inventory etc.
    private final PcInventory _inventory = new PcInventory(this);
    // Warehouse / Freight simplified
    private final Warehouse _warehouse = new PcWarehouse(this);
    private final PcFreight _freight = new PcFreight(this);

    // A few more container references
    private final ShortCutList _shortCuts = new ShortCutList(this);
    private final MacroList _macroses = new MacroList(this);

    // ============= AutoFarm State Field =============
    /**
     * This reference holds the player's auto-farming configuration/state,
     * so external code can do player.getAutoFarmState() or setAutoFarmState(...).
     */
    private AutoFarmState _autoFarmState;  // <--- Add this field

    // ============= Constructors =============
    public Player(final int objectId, final PlayerTemplate template, final String accountName)
    {
        super(objectId, template);
        _login = accountName;
        setNameColor(0xFFFFFF);
    }

    // A basic create-flow constructor
    private Player(final int objectId, final PlayerTemplate template)
    {
        this(objectId, template, null);
        _ai = new PlayerAI(this);
    }

    // ============= Overriding L2Character / Playable Methods =============
    @SuppressWarnings("unchecked")
    @Override
    public HardReference<Player> getRef()
    {
        return (HardReference<Player>) super.getRef();
    }

    @Override
    public PlayerAI getAI()
    {
        return (PlayerAI) _ai;
    }

    @Override
    public final boolean isAutoAttackable(Creature attacker)
    {
        // Minimal check for PK/PvP logic
        if (attacker == null || isAlikeDead())
            return false;
        // Very simplified logic
        return getKarma() > 0 || (_pvpFlag > 0);
    }

    @Override
    public boolean isInParty()
    {
        return _party != null;
    }

    @Override
    public Party getParty()
    {
        return _party;
    }

    public void setParty(Party party)
    {
        _party = party;
    }

    @Override
    public int getLevel()
    {
        return getActiveClass() == null ? 1 : getActiveClass().getLevel();
    }

    @Override
    public void onAction(Player player, boolean shift)
    {
        if (isFrozen())
        {
            player.sendPacket(ActionFail.STATIC);
            return;
        }
        // Minimal "attack or select" logic
        if (player.getTarget() != this)
        {
            player.setTarget(this);
            player.sendPacket(new MyTargetSelected(getObjectId(), 0));
        }
        else if (isAutoAttackable(player))
        {
            player.getAI().Attack(this, false, shift);
        }
        else
        {
            // Follow or cancel
            if (player.getAI().getIntention() != CtrlIntention.AI_INTENTION_FOLLOW)
                player.getAI().setIntention(CtrlIntention.AI_INTENTION_FOLLOW, this, Config.FOLLOW_RANGE);
            else
                player.sendPacket(ActionFail.STATIC);
        }
    }

    @Override
    public void doPickupItem(final GameObject object)
    {
        if (!object.isItem())
        {
            _log.warn("trying to pickup wrong target: {}", object);
            return;
        }
        sendActionFailed();
        stopMove();
        ItemInstance item = (ItemInstance) object;

        synchronized (item)
        {
            if (!item.isVisible())
                return;

            // The actual pickup logic simplified
            if (!ItemFunctions.checkIfCanPickup(this, item))
            {
                SystemMessage sm;
                if (item.getItemId() == 57)
                {
                    sm = new SystemMessage(SystemMessage.YOU_HAVE_FAILED_TO_PICK_UP_S1_ADENA);
                    sm.addNumber(item.getCount());
                }
                else
                {
                    sm = new SystemMessage(SystemMessage.YOU_HAVE_FAILED_TO_PICK_UP_S1);
                    sm.addItemName(item.getItemId());
                }
                sendPacket(sm);
                return;
            }

            if (pickupItem(item, "Pickup"))
            {
                broadcastPacket(new GetItem(item, getObjectId()));
                broadcastPickUpMsg(item);
                item.pickupMe();
            }
        }
    }

    public boolean pickupItem(ItemInstance item, String log)
    {
        if (!ItemFunctions.canAddItem(this, item))
            return false;
        Log.LogItem(this, log, item);
        sendPacket(SystemMessage2.obtainItems(item));
        getInventory().addItem(item);
        sendChanges();
        return true;
    }

    // ============= Movement / Summon / Sit/Stand =============
    @Override
    public void sitDown(StaticObjectInstance throne)
    {
        if (isSitting() || isAlikeDead())
            return;
        // Minimal seat logic
        setSitting(true);
        broadcastPacket(new ChangeWaitType(this, ChangeWaitType.WT_SITTING));
    }

    @Override
    public void standUp()
    {
        if (!isSitting() || isAlikeDead())
            return;
        // Minimal stand logic
        setSitting(false);
        broadcastPacket(new ChangeWaitType(this, ChangeWaitType.WT_STANDING));
    }

    public boolean isSitting()
    {
        return _isSitting;
    }

    public void setSitting(boolean val)
    {
        _isSitting = val;
    }

    // ============= Basic “Dead” logic =============
    @Override
    protected void onDeath(Creature killer)
    {
        super.onDeath(killer);
        // Additional logic can be added if needed
        if (isInParty())
            getParty().broadcastToPartyMembers(new SystemMessage(getName() + " has been killed!"));
    }

    // ============= Basic Summon logic =============
    @Override
    public Summon getPet()
    {
        return _summon;
    }
    public void setPet(Summon summon)
    {
        _summon = summon;
    }

    // ============= Basic Targeting =============
    @Override
    public void setTarget(GameObject newTarget)
    {
        if (newTarget != null && !newTarget.isVisible())
            newTarget = null;

        GameObject oldTarget = getTarget();
        if (oldTarget != null && oldTarget.equals(newTarget))
            return;

        super.setTarget(newTarget);
        if (newTarget != null)
            broadcastPacket(new MyTargetSelected(getObjectId(), newTarget.getObjectId()));
        else
            broadcastPacket(ActionFail.STATIC);
    }

    // ============= Basic broadcast =============
    @Override
    public void broadcastCharInfo()
    {
        // Minimal
        sendUserInfo(true);
        if (!isVisible())
            return;
        L2GameServerPacket ci = isPolymorphed() ? new NpcInfoPoly(this) : new CharInfo(this);
        for (Player player : World.getAroundPlayers(this))
            if (!isInvisible())
                player.sendPacket(ci);
    }

    public void sendUserInfo(boolean force)
    {
        if (!isVisible() || isLogoutStarted())
            return;
        sendPacket(new UserInfo(this));
    }

    // ============= Basic Logging out / store =============
    public void logout()
    {
        if (_connection != null)
        {
            _connection.close(ServerClose.STATIC);
            setNetConnection(null);
        }
        prepareToLogout();
        deleteMe();
    }

    private void prepareToLogout()
    {
        if (_isLogout.getAndSet(true))
            return;
        setNetConnection(null);
        setIsOnline(false);
        if (isInParty())
            leaveParty();
    }

    // ============= Party logic =============
    public void joinParty(final Party party)
    {
        if (party != null)
            party.addPartyMember(this);
    }

    public void leaveParty()
    {
        if (isInParty())
            _party.removePartyMember(this, false);
    }

    // ============= Accessors & Misc =============
    public int getKarma()
    {
        return _karma;
    }

    public void setKarma(int karma)
    {
        _karma = karma;
    }

    public boolean isLogoutStarted()
    {
        return _isLogout.get();
    }

    public void setIsOnline(boolean isOnline)
    {
        _isOnline = isOnline;
    }

    public boolean isOnline()
    {
        return _isOnline;
    }

    public void setOfflineMode(boolean val)
    {
        _offline = val;
    }

    public boolean isInOfflineMode()
    {
        return _offline;
    }

    public GameClient getNetConnection()
    {
        return _connection;
    }

    public void setNetConnection(final GameClient connection)
    {
        _connection = connection;
    }

	// ============= AutoFarm Accessors =============
	/**
	 * Returns the associated AutoFarmState reference, or null if none.
	 */
	public AutoFarmState getAutoFarmState() // <--- Add this method
	{
		return _autoFarmState;
	}

	/**
	 * Assigns a new AutoFarmState reference, which you might store in your
	 * global map as well. Typically used by your AutoFarmEngine.
	 */
	public void setAutoFarmState(AutoFarmState state) // <--- Add this method
	{
		_autoFarmState = state;
	}


    // ============= Summaries of big blocks omitted =============
    // (We removed large, specialized chunks dealing with clan, 
    //  requests/trade, warehouse expansions, achievement systems, etc.)

    // ============= End =============
}
// ============================================================================
// ================= END MINIMIZED Player.java ================================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Player.java>

<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Skill.java>
// ============================================================================
// ====================== MINIMIZED Skill.java ================================
// ============================================================================

package l2ft.gameserver.model;

import l2ft.gameserver.templates.StatsSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized Skill class for our MVP.
 *
 * Retains only fields & methods that are relevant to:
 * - Checking skill ID, name, level, power.
 * - Basic checks for "isOffensive()" or "isMagic()", etc.
 * - References that appear in Creature/Player code (like getPower(), useSkill()).
 */
public abstract class Skill
{
    private static final Logger _log = LoggerFactory.getLogger(Skill.class);

    // Basic skill properties
    protected int _id;
    protected int _level;
    protected String _name = "UnnamedSkill";

    protected double _power = 0;       // e.g. damage or heal power
    protected boolean _isOffensive;    // e.g. is it an attack skill
    protected boolean _isMagic;        // is it a "magic" skill?

    // (We skip many fields like castRange, effect templates, itemConsume, etc.)

    // Basic constructor
    protected Skill(StatsSet set)
    {
        _id = set.getInteger("skill_id");
        _level = set.getInteger("level");
        _name = set.getString("name", "UnnamedSkill");
        _power = set.getDouble("power", 0.0);
        _isOffensive = set.getBool("isOffensive", false);
        _isMagic = (set.getEnum("magicType", SkillMagicType.class, SkillMagicType.PHYSIC) == SkillMagicType.MAGIC);
    }

    // Enums used in the code
    public static enum SkillMagicType
    {
        PHYSIC, MAGIC, SPECIAL, MUSIC
    }

    /** Basic getters. **/
    public int getId()
    {
        return _id;
    }
    public int getLevel()
    {
        return _level;
    }
    public String getName()
    {
        return _name;
    }
    public double getPower()
    {
        return _power;
    }
    public boolean isOffensive()
    {
        return _isOffensive;
    }
    public boolean isMagic()
    {
        return _isMagic;
    }

    /**
     * Called by Creature.doAttack(...) or other places to "use" the skill.
     * Typically, you'd handle effect logic or actual damage here. 
     * For MVP, we just log that it's invoked.
     */
    public void useSkill(Creature activeChar)
    {
        _log.info("Skill [{}:{}] used by {}", _name, _level, activeChar);
        // Minimally, we might handle MP consumption or do basic damage 
        // but for the MVP, we are skipping advanced logic.
    }

    @Override
    public String toString()
    {
        return "Skill[ID=" + _id + ", lvl=" + _level + ", name=" + _name + "]";
    }
}
// ============================================================================
// ====================== END MINIMIZED Skill.java ============================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Skill.java>
<InertiaController.java>
<C:\l2sq\assets\autofarm\src\controller\InertiaController.java>
package inertiax.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import drake.aepvp.authentication.PassportManager;
import drake.aepvp.authentication.PlayerPassport;
import drake.aepvp.model.controlers.RealTimeController;
import drake.aepvp.model.interfaces.ITimeTrigger;
import gnu.trove.map.hash.TIntLongHashMap;
import inertiax.enums.EActionPriority;
import inertiax.enums.EAutoAttack;
import inertiax.enums.EMoveType;
import inertiax.enums.EPanelOption;
import inertiax.enums.ESearchType;
import inertiax.model.Inertia;
import inertiax.model.InertiaAct;
import l2.ae.pvp.L2DatabaseFactory;
import l2.ae.pvp.gameserver.Shutdown;
import l2.ae.pvp.gameserver.ThreadPoolManager.PriorityThreadFactory;
import l2.ae.pvp.gameserver.model.IBypassHandler;
import l2.ae.pvp.gameserver.model.IStorable;
import l2.ae.pvp.gameserver.model.actor.instance.L2PcInstance;
import l2.ae.pvp.gameserver.network.clientpackets.RequestBypassToServer;
import l2.ae.pvp.gameserver.network.serverpackets.NpcHtmlMessage;

public class InertiaController implements IBypassHandler, IStorable, ITimeTrigger
{
	public static long TICKS = 800;
	
	private final TIntLongHashMap _playerCredit = new TIntLongHashMap();
	
	private final ConcurrentHashMap<PlayerPassport, Inertia> _playerInertias = new ConcurrentHashMap<>();
	
	private static final ScheduledExecutorService INERTIA_MAIN = Executors.newSingleThreadScheduledExecutor();
	private static final ThreadPoolExecutor       INERTIA_POOL = new ThreadPoolExecutor(4, 6, 5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new PriorityThreadFactory("INERTIAX Pool", Thread.NORM_PRIORITY)); 

	private final InertiaTask _inertiaTask = new InertiaTask();
	
	private InertiaController()
	{
		RequestBypassToServer.register(this);
		Shutdown.getInstance().addShutdownHook(this);
		RealTimeController.registerHook(this);
		
		_inertiaTask.execute(1000);
		
		load();
	}
	
	public void stop()
	{
		_inertiaTask.stop();
	}
	
	public void start()
	{
		_inertiaTask.start();
	}
	
	public boolean isRunning()
	{
		return _inertiaTask.isRunning();
	}
	
	public void setTicks(final long ticks)
	{
		TICKS = ticks;
	}
	
	public long getLag()
	{
		return _inertiaTask.getLag();
	}
	
	private class InertiaTask implements Runnable
	{
		private long _lag;
		
		private boolean _running = true;
		
		private final List<Callable<Inertia>> callables = new ArrayList<>(100);
		
		@Override
		public void run()
		{
			final long t0 = System.nanoTime();
			
			callables.addAll(_playerInertias.values());
			
			if (callables.size() > 0) try
			{
				INERTIA_POOL.invokeAll(callables, TICKS, TimeUnit.MILLISECONDS);
				callables.clear();
			}
			catch (InterruptedException e)
			{
				stop();
				e.printStackTrace();
			}

			_lag = System.nanoTime() - t0;
			final long delay = TICKS - TimeUnit.NANOSECONDS.toMillis(_lag);
			execute(delay);
			

//			System.out.println(String.format("%.02f", _lag / 1000_000d));
		}
		
		public long getLag()
		{
			return _lag;
		}
		
		public void execute(final long delay)
		{
			if (isRunning())
				INERTIA_MAIN.schedule(this, delay, TimeUnit.MILLISECONDS);
		}
		
		public void stop()
		{
			_running = false;
		}
		
		public void start()
		{
			if (_running)
				throw new RuntimeException("Already Running!");
			
			_running = true;
			execute(0);
		}
		
		private boolean isRunning()
		{
			return _running;
		}
	}
	
	private final String SET_ON = "<tr><td><font name=hs12 color=\"LEVEL\">InertiaX Core</font></td><td align=center><font name=hs12 color=\"63FF63\">Active</font></td><td align=center><button value=\"Shutdown\" action=\"bypass admin_inertia_shutdown\" width=80 height=25 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td></tr>";
	private final String SET_OF = "<tr><td><font name=hs12 color=\"LEVEL\">InertiaX Core</font></td><td align=center><button value=\"Active\" action=\"bypass admin_inertia_activate\" width=80 height=25 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td><td align=center><font name=hs12 color=\"FF6363\">Shutdown</font></td></tr>";

	public void adminPanel(final L2PcInstance player)
	{
		final var npcHtml = new NpcHtmlMessage();
		npcHtml.setFile(player, "data/html/aepvp/inertiax/admin.htm");
		
		
		npcHtml.replace("%state%", isRunning() ? SET_ON : SET_OF);

		final var list = new ArrayList<>(Arrays.asList(300L, 500L, 600L, 800L, 900L, 1300L, 1600L, 1800L, 2200L, 2600L, 3300L, 3800L, 4400L, 5500L, 6200L));
		list.remove(Long.valueOf(TICKS));
		
		String ticks = String.valueOf(TICKS);
		for (final var tick : list)
			ticks += ";" + tick;
		
		npcHtml.replace("%ticks%", ticks);

		npcHtml.replace("%lag%", String.format("%.02f", getLag() / 1000_000d));
		

		npcHtml.replace("%count%", String.format("%d / %d", _playerInertias.values().stream().filter(Inertia::isRunning).count(), _playerInertias.size()));
		
		player.sendPacket(npcHtml);
	}
	
	public Inertia fetchInertia(final L2PcInstance player)
	{
		final var playerPassport = player.getPassport();
		
		return fetchInertia(playerPassport);
	}
	
	public Inertia fetchInertia(final PlayerPassport playerPassport)
	{
		var inertia = _playerInertias.get(playerPassport);
		
		if (inertia == null)
		{
			final var player = playerPassport.getPlayer();
			
			inertia = new Inertia(playerPassport, _playerCredit.get(playerPassport.getObjectId()));
			final InertiaAct inertiaAct = inertia.getInertiaAct();
			player.processInertiaAct(inertiaAct);
			
			_playerInertias.put(playerPassport, inertia);
		}
		
		return inertia;
	}
	
	public Inertia findInertia(final L2PcInstance player, final int viewId)
	{
		final var passport = PassportManager.getInstance().getById(viewId);
		
		if (player.getPassport() != passport && player.isGM())
			return fetchInertia(passport);
		
		return fetchInertia(player);
			
		
	}
	
	public Inertia getInertia(final L2PcInstance player)
	{
		return _playerInertias.get(player.getPassport());
	}

	@Override
	public boolean handleBypass(L2PcInstance player, String cmd)
	{
		if (!cmd.contains("inertia") || cmd.contains("admin"))
			return false;
		
		final StringTokenizer st = new StringTokenizer(cmd);
		st.nextToken();
		
		if (!st.hasMoreTokens())
			return false;
		
		final int viewId = Integer.parseInt(st.nextToken());

		final var inertia = findInertia(player, viewId);
		
		if (cmd.startsWith("inertia_start"))
		{
			inertia.setRunning(true);
			inertia.render(player);
			return true;
		}
		else if (cmd.startsWith("inertia_stop"))
		{
			inertia.setRunning(false);
			inertia.render(player);
			return true;
		}
		else if (cmd.startsWith("inertia_reset"))
		{
			inertia.reset();
			inertia.render(player);
			return true;
		}
		else if (cmd.startsWith("inertia_refresh") || cmd.startsWith("inertia_main"))
		{
			inertia.render(player);
	
			return true;
		}
		else if (cmd.startsWith("inertia_attack_type"))
		{
			if (st.hasMoreTokens())
			{
				String strType = st.nextToken();
				while (st.hasMoreTokens())
					strType += "_" + st.nextToken();
				final EAutoAttack attackType = Enum.valueOf(EAutoAttack.class, strType);
				inertia.setAutoAttack(attackType);
				inertia.render(player);
			}
		}
		else if (cmd.startsWith("inertia_move_type"))
		{
			if (st.hasMoreTokens())
			{
				String strType = st.nextToken();
				while (st.hasMoreTokens())
					strType += "_" + st.nextToken();
				final EMoveType attackType =  strType.contains("Follow") ? EMoveType.Follow_Target : Enum.valueOf(EMoveType.class, strType);
				inertia.setMoveType(attackType);
				inertia.render(player);
			}
			
			return true;
		}
		else if (cmd.startsWith("inertia_search_type"))
		{
			if (st.hasMoreTokens())
			{
				final ESearchType searchType = Enum.valueOf(ESearchType.class, st.nextToken());
				inertia.setSearchTarget(searchType);
				inertia.render(player);
			}
			
			return true;
		}
		else if (cmd.startsWith("inertia_party_target"))
		{
			if (st.hasMoreTokens())
			{
				String name = st.nextToken();
				while (st.hasMoreTokens())
					name += "_" + st.nextToken();
				
				final var targetPassport = PassportManager.getInstance().getByName(name);
				
				inertia.setPartyTarget(targetPassport);
				inertia.render(player);
					
			}
			return true;
		}
		else if (cmd.startsWith("inertia_action_edit"))
		{
			final int slot = Integer.parseInt(st.nextToken());
			
			int page = 0;
			if (st.hasMoreTokens())
				page = Integer.parseInt(st.nextToken());

			inertia.renderActionEdit(slot, page);
			return true;
		}
		else if (cmd.startsWith("inertia_action_set"))
		{
			if (st.hasMoreTokens())
			{
				final int slot = Integer.parseInt(st.nextToken());
				if (st.hasMoreTokens())
				{
					final int acid = Integer.parseInt(st.nextToken());
					
					inertia.setInertiaAction(slot, acid, true);

					inertia.renderActionEdit(slot, 0);
				}
			}
			return true;
		}
		else if (cmd.startsWith("inertia_reuse_set"))
		{
			if (st.hasMoreTokens())
			{
				final int slot = Integer.parseInt(st.nextToken());
				if (st.hasMoreTokens())
				{
					final double reus = Double.parseDouble(st.nextToken());
					
					final var action = inertia.getInertiaAction(slot, true);
					if (action != null)
						action.setReuse(reus);
					
					inertia.renderActionEdit(slot, 0);
				}
			}
			return true;
		}
		else if (cmd.startsWith("inertia_hpp_set"))
		{
			if (st.hasMoreTokens())
			{
				final int slot = Integer.parseInt(st.nextToken());
				if (st.hasMoreTokens())
				{
					final double userHp = Double.parseDouble(st.nextToken());
					
					final var action = inertia.getInertiaAction(slot, true);
					if (action != null)
						action.setUserHP(userHp);
					
					inertia.renderActionEdit(slot, 0);
				}
			}
			return true;
		}
		else if (cmd.startsWith("inertia_tpp_set"))
		{
			if (st.hasMoreTokens())
			{
				final int slot = Integer.parseInt(st.nextToken());
				if (st.hasMoreTokens())
				{
					final double targHp = Double.parseDouble(st.nextToken());
					
					final var action = inertia.getInertiaAction(slot, true);
					if (action != null)
						action.setTargetHP(targHp);
					
					inertia.renderActionEdit(slot, 0);
				}
			}
		}
		else if (cmd.startsWith("inertia_slot_set"))
		{
			if (st.hasMoreTokens())
			{
				final int slot0 = Integer.parseInt(st.nextToken());
				if (st.hasMoreTokens())
				{
					final int slot1 = Integer.parseInt(st.nextToken()) - 1;
					
					final var action = inertia.getInertiaAction(slot0, true);
					
					final var newPriority = EActionPriority.values()[slot1];
					if (newPriority == EActionPriority.Remove)
					{
						inertia.deleteInertiaAction(slot0, action.isSkill());
						inertia.render();
					}
					else if (inertia.swapInertiaAction(slot0, slot1, action.isSkill()))
						inertia.renderActionEdit(slot1, 0);
				}
			}
			return true;
		}
		
		
		//MENU
		else if (cmd.startsWith("inertia_render_panel"))
		{
			if (st.hasMoreTokens())
			{
				final int ord = Integer.parseInt(st.nextToken()) - 1;
				final var panelOptions = EPanelOption.values();
				if (ord < panelOptions.length)
				{
					final var panelOption = panelOptions[ord];
					panelOption.render(inertia, player);
				}
			}
			return true;
		}
		else if (cmd.startsWith("inertia_panel"))
		{
			for (final var panelOption : EPanelOption.values())
			{
				final String cmdeq = String.format("inertia_panel_%s", panelOption.toLowerCase());
				if (cmd.startsWith(cmdeq))
				{
					final var inertiaPanel = inertia.fetchPanel(panelOption);
					inertiaPanel.onBypass(player, st);
					break;
				}
			}
			return true;
		}

		return false;
	}
	
	public void renderInertia(final L2PcInstance player)
	{
		final var inertia = fetchInertia(player);
		inertia.render(player);
	}
	
	private static class InstanceHolder
	{
		private static final InertiaController _instance = new InertiaController();
	}
	
	public static InertiaController getInstance()
	{
		return InstanceHolder._instance;
	}

	@Override
	public void exception(Exception e)
	{
		e.printStackTrace();
	}

	@Override
	public boolean storeMe()
	{
		final long t0 = System.currentTimeMillis();
		
		try (final var con = L2DatabaseFactory.getConnectionS();
			 final var pst = con.prepareStatement("INSERT INTO character_inertia_credit (owner_id, credits) VALUES (?, ?) ON DUPLICATE KEY UPDATE credits = ?"))
		{
			con.setAutoCommit(false);
			for (final var inertiaSet : _playerInertias.entrySet())
			{
				final var playerPassport = inertiaSet.getKey();
				final var inertia = inertiaSet.getValue();

				pst.setInt(1, playerPassport.getObjectId());
				pst.setLong(2, inertia.getCredit());
				pst.setLong(3, inertia.getCredit());
				
				pst.addBatch();
				
			}
			
			
			final int total = pst.executeBatch().length;

			con.commit();
			
			final long t1 = System.currentTimeMillis();
			
			System.err.println("Updates " + total + " player Inertia credits in " + (t1 - t0) + " ms!!!" );
			
			return true;
			
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return false;
		}
	}
	
	public void load()
	{
		try (final var con = L2DatabaseFactory.getConnectionS();
			 final var  st = con.createStatement();
			 final var  rs = st.executeQuery("SELECT * FROM character_inertia_credit"))
		{
			while (rs.next())
			{
				final int ownerId = rs.getInt("owner_id");
				final var credit = rs.getLong("credits");
				
				_playerCredit.put(ownerId, credit);
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}

	@Override
	public void notify(String dayName, String timeString)
	{
//		if (timeString.equals(Config.DAILY_CREDIT_TIME))
//		{
//			for (final var autoChill : _playerChills.values())
//			{
//				autoChill.addCredit(Config.DAILY_CREDIT);
//				final var player = autoChill.getActivePlayer();
//
//				if (player != null)
//				{
//					player.sendMessage(String.format("You have been rewarded with %.2f hours of daily auto chill credit.", Config.DAILY_CREDIT / 3_600_000D));
//					
//					if(player.isPremium())
//					{
//						autoChill.addCredit(Config.DAILY_CREDIT_PREMIUM_BONUS);
//						player.sendMessage(String.format("You have been rewarded with extra %.2f hours.", Config.DAILY_CREDIT_PREMIUM_BONUS / 3_600_000D));
//					}
//					
//				}
//			}
//		}
	}
	
	

}


</C:\l2sq\assets\autofarm\src\controller\InertiaController.java>
</InertiaController.java>
<Inertia.java>
<C:\l2sq\assets\autofarm\src\model\Inertia.java>
package inertiax.model;

import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__ASSIST_NO_TARGET;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__ATK_TARGET;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__CREDIT_END;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__END;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__FOLLOW_CLOSE;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__FOLLOW_FAR;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__NEW_TARGET;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__NO_TARGET;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__ON_KILL;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__REM_TARGET;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__START;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__WHILE_DEAD;
import static inertiax.enums.IInertiaCmd.EInertiaEvt.EVT__WHILE_TARGET_DEAD;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.stream.Stream;

import drake.aepvp.authentication.PlayerPassport;
import drake.aepvp.model.controlers.GlobalRadar;
import ghosts.model.Ghost;
import inertiax.controller.InertiaController;
import inertiax.enums.EActionPriority;
import inertiax.enums.EAutoAttack;
import inertiax.enums.EMoveType;
import inertiax.enums.EPanelOption;
import inertiax.enums.ESearchType;
import inertiax.enums.IInertiaCmd.EInertiaEvt;
import inertiax.model.ext.InertiaExt;
import inertiax.model.filters.ActionFilter;
import inertiax.model.filters.AvailSkillActionFilter;
import inertiax.model.filters.TargetFilter;
import inertiax.model.filters.VTargetFilter;
import inertiax.model.panels.DropTracker;
import inertiax.model.panels.TargetFiltering;
import l2.ae.pvp.gameserver.datatables.SkillTable;
import l2.ae.pvp.gameserver.model.ILocational;
import l2.ae.pvp.gameserver.model.L2Skill;
import l2.ae.pvp.gameserver.model.Location;
import l2.ae.pvp.gameserver.model.actor.L2Character;
import l2.ae.pvp.gameserver.model.actor.instance.L2PcInstance;
import l2.ae.pvp.gameserver.network.serverpackets.ExServerPrimitive;
import l2.ae.pvp.gameserver.network.serverpackets.NpcHtmlMessage;
import l2.ae.pvp.gameserver.util.Util;

public class Inertia implements Callable<Inertia>
{
	private final int _ownerId;

	private final long INIT_TICKS = 4 * 3_600_000;

//	private final IInertiaBehave _behave;
	private final InertiaAct _inertiaAct = new InertiaAct(this);
	
	private final PlayerPassport _playerPassport;

	private boolean _running;
	private long _lagTicks;
	private long _remainingTicks = INIT_TICKS;
	private EAutoAttack _autoAttack;
	private EMoveType _moveType;
	private ESearchType _searchType;
	private PlayerPassport _assistPassport;
	private Location _lastSavedLocation;
	private final InertiaCast[] _inertiaSkills = new InertiaCast[7];
	private final TargetComparator targetComperator = new TargetComparator();
	private final TargetFilter _targetFilter = new TargetFilter(this);
	private final VTargetFilter _vtargetFilter = new VTargetFilter(this);
	private final ActionFilter actionFilter = new ActionFilter(this);
	private final AvailSkillActionFilter availSkillFilter = new AvailSkillActionFilter(this);

	private boolean _exit;

	private final HashMap<EPanelOption, InertiaPanel> _panels = new HashMap<>();

	@Override
	public Inertia call()
	{
		if (_running)
		{
			tick(InertiaController.TICKS);
			tickEnd();
			_exit = false;
		}
		return this;
	}
	
	public InertiaAct getInertiaAct()
	{
		return _inertiaAct;
	}

	public Inertia(final PlayerPassport playerPassport, final long remainingTicks)
	{
		_ownerId = playerPassport.getObjectId();
		_playerPassport = playerPassport;
		if (remainingTicks > 0)
			_remainingTicks = remainingTicks;
		else
			_remainingTicks = INIT_TICKS;

		reset();
	}

	public InertiaCast setInertiaAction(int slot, int actionId, boolean isSkill)
	{
		final var inertiaSlots = _inertiaSkills;
		final int slotsLen = inertiaSlots.length;
		if (slot >= slotsLen)
			return null;
		return inertiaSlots[slot] = new InertiaCast(actionId, isSkill);
	}

	public InertiaCast getInertiaAction(int slot, final boolean isSkill)
	{
		final var inertiaSlots = _inertiaSkills;
		if (slot < 0 || slot >= inertiaSlots.length)
			return null;
		return inertiaSlots[slot];
	}

	public boolean swapInertiaAction(final int slot0, final int slot1, final boolean isSkill)
	{
		final var inertiaSlots = _inertiaSkills;
		if (slot0 < 0 || slot0 >= inertiaSlots.length)
			return false;
		if (slot1 < 0 || slot1 >= inertiaSlots.length)
			return false;
		final var inertAction = inertiaSlots[slot0];
		inertiaSlots[slot0] = inertiaSlots[slot1];
		inertiaSlots[slot1] = inertAction;
		return true;
	}

	public void addLag(final long newLag)
	{
		_lagTicks += newLag;
	}

	public void deleteInertiaAction(final int slot0, final boolean isSkill)
	{
		final var inertiaSlots = _inertiaSkills;
		inertiaSlots[slot0] = null;
	}

	public void addCredit(final long ticks)
	{
		_remainingTicks += ticks;
	}

	public long getCredit()
	{
		return _remainingTicks;
	}

	public void turnOff()
	{
		setRunning(false);
		render();
		return;
	}

	public boolean exit()
	{
		return _exit;
	}

	public void raiseExit()
	{
		_exit = true;
	}

	public void tick(final long ticks)
	{
		final var player = getActivePlayer();

		if (player == null)
		{
			setRunning(false);
			return;
		}

		if (player.isDead())
		{
			evt(EVT__WHILE_DEAD);
			if (exit())
				return;
		}
		if (_remainingTicks - ticks < 0 || player == null)
		{
			_remainingTicks = 0;
			evt(EVT__CREDIT_END);
			if (exit())
				return;
		}
//		_remainingTicks -= ticks;
		if (_lagTicks > 0)
		{
			_lagTicks = Math.max(0, _lagTicks - ticks);
			return;
		}
		
		_inertiaAct.tick(ticks);
		_inertiaAct.evt(EVT__START);
		
		// final var oldTarget = player.getTarget();
		// if (! (player.getTarget() instanceof L2Character))
		// return;
		final L2Character oldTarget = (L2Character) player.getTarget();
		if (oldTarget != null && oldTarget.isAlikeDead())
		{
			evt(EVT__REM_TARGET);
//			addLag(1000);
			return;
		}
		final var party = player.getParty();
		final var assistPlayer = getAssistPlayer();
		if (assistPlayer != null && !assistPlayer.isSamePartyWith(player))
			_assistPassport = null;

		if (party == null || _assistPassport == null)
		{
			boolean render = false;
			if (_moveType == EMoveType.Follow_Target)
			{
				setMoveType(EMoveType.Not_Set);
				render = true;
			}
			if (_searchType == ESearchType.Assist)
			{
				setSearchTarget(ESearchType.Off);
				render = true;
			}
			if (render)
				render();
		}

		final L2Character currTarget = player.getTargetChar();

		if (assistPlayer != null)
		{
			if (_moveType == EMoveType.Follow_Target && !player.isMoving())
			{
				if (player.isInsideRadius(assistPlayer, 500, false) || player.isInCombat())
				{
					evt(EVT__FOLLOW_CLOSE);
				} 
				else
				{
					evt(EVT__FOLLOW_FAR);
				}
			}
			if (currTarget == null)
			{
				evt(EVT__ASSIST_NO_TARGET);
			}
		}

		if (_searchType != ESearchType.Off)
		{
			if (_moveType == EMoveType.Not_Set)
				renderRange();
			if (currTarget != null && currTarget.isAlikeDead())
			{
				evt(EVT__WHILE_TARGET_DEAD);
			} 
			else if (currTarget == null || (currTarget == player) || _searchType == ESearchType.Assist)
			{
				final L2Character newTarget = searchTarget();
				if (newTarget != null && newTarget != currTarget)
				{
					_inertiaAct.setTarget(newTarget);
					evt(EVT__NEW_TARGET);
					return;
				}
			}
		}
		L2Character actualTarget = player.getTargetChar();
		if (actualTarget == null)
		{
			evt(EVT__NO_TARGET);
			actualTarget = _inertiaAct.getTarget();
		}

		if (actualTarget == null)
			return;
		
//		final L2Character playerTarget = actualTarget.getActingPlayer();
//		 if (playerTarget != null && playerTarget.isSameHWID(player) && playerTarget != player)
//		 {
//			 player.sendMessage("Its not allowed to auto chill targets from the same IP!");
//			 setRunning(false);
//			 render();
//		 }
		if (actualTarget.isAutoAttackable(player) && forceAutoAttack())
		{
			startAutoAttack(actualTarget);
			return;
		}
		else
		{
			final var avail = getAvailSkillActions().filter(availSkillFilter).findFirst();
			if (avail != null && avail.isPresent())
			{
				final InertiaCast availCast = avail.get();
				if (availCast != null)
				{

					final L2Skill availSkill = getSkill(availCast);

					if (availSkill != null)
					{
						if (availSkill.isOffensive() && !actualTarget.isAutoAttackable(player))
							player.setTarget(null);
							
						if (player.testDoCastConditions(availSkill))
						{
							if (player.useMagic(availSkill, false, false))
							{
								availCast.initReuse();
								return;
							}

						}
						if (_autoAttack != EAutoAttack.Never)
						{
							startAutoAttack(actualTarget);
							return;
						}
					}
				}
			} 
			else if (_autoAttack == EAutoAttack.Skills_Reuse)
			{
				startAutoAttack(actualTarget);
				return;
			}
		}
	}
	
	public L2Skill getSkill(final InertiaCast inertiaCast)
	{
		final L2PcInstance activePlayer = getActivePlayer();
		if (activePlayer == null)
			return null;
		
		final int skillLvl = activePlayer.getSkillLevel(inertiaCast.getActionId());
		return SkillTable.getInstance().getInfo(inertiaCast.getActionId(), skillLvl);
	}

	private boolean forceAutoAttack()
	{
		if (_autoAttack == EAutoAttack.Always)
			return true;
		else if (_autoAttack == EAutoAttack.Skills_Reuse && cantAction())
			return true;

		return false;
	}

	private boolean cantAction()
	{
		final var player = getActivePlayer();
		for (final var inertiaSkill : _inertiaSkills)
		{
			if (inertiaSkill != null && !inertiaSkill.isUsableNow(player))
				return false;
		}

		return false;
	}

	public void tickEnd()
	{
		evt(EVT__END);
	}

	public void onLogout()
	{
		_running = false;
	}

	public void onKill(final L2Character victim)
	{
		//addLag(700);
		evt(EVT__ON_KILL);
	}

	private void startAutoAttack(final L2Character actualTarget)
	{
		_inertiaAct.setTarget(actualTarget);
		evt(EVT__ATK_TARGET);
	}

	private Stream<InertiaCast> getAvailSkillActions()
	{
		return Stream.of(_inertiaSkills).filter(actionFilter);
	}

	public L2Character searchTarget()
	{

		switch (_searchType)
		{
		case Assist:
			return getTargetByAssist();
		}

		final var target = _inertiaAct.getTarget();
		if (target != null)
			return target;

		return getTargetByRange(_searchType.getRange());
	}

	public L2Character getTargetByAssist()
	{
		final var assistPlayer = getAssistPlayer();
		if (assistPlayer == null)
			return null;
		return assistPlayer.getTargetChar();
	}

	public L2Character getTargetByRange(final int range)
	{
		final var player = getActivePlayer();

		return player.getKnownList().getKnownCharacters().stream().filter(_targetFilter).sorted(targetComperator)

				.findFirst().orElse(null);
	}

	public ILocational getSearchLocation()
	{
		final var loc = _moveType == EMoveType.Saved_Location ? _lastSavedLocation : getActivePlayer();
		return loc;
	}

	private class TargetComparator implements Comparator<L2Character>
	{
		@Override
		public int compare(L2Character o1, L2Character o2)
		{
			final var loc = getSearchLocation();
			final double d1 = GlobalRadar.getRadarDistance(loc, o1);
			final double d2 = GlobalRadar.getRadarDistance(loc, o2);

			return Double.compare(d1, d2);
		}
	}

	public L2PcInstance getActivePlayer()
	{
		final var player = _playerPassport.getOnlinePlayer();
		return player;
	}

	public L2PcInstance getAssistPlayer()
	{
		if (_assistPassport == null)
			return null;
		return _assistPassport.getOnlinePlayer();
	}

	public void reset()
	{
		_running = false;
		_autoAttack = EAutoAttack.Never;
		_searchType = ESearchType.Off;
		_moveType = EMoveType.Not_Set;
		_assistPassport = null;
		_lastSavedLocation = null;
		Util.clearArray(_inertiaSkills);
		renderRange();
	}

	public void setPartyTarget(final PlayerPassport targetPassport)
	{
		if (targetPassport == _assistPassport || targetPassport == _playerPassport)
			return;
		final var player = getActivePlayer();
		if (targetPassport != null)
		{
			final var targetPlayer = targetPassport.getPlayer();
			if (targetPlayer == null)
				return;
			if (player.isSameHWID(targetPlayer))
			{
				_assistPassport = null;
				player.sendMessage("Same IP inertia is prohibited and a bannable offense.");
				return;
			}
		}
		_assistPassport = targetPassport;
		if (_assistPassport == null)
		{
			player.sendMessage("InertiaMode PartyTarget changed to -> UNSET");
			if (_moveType == EMoveType.Follow_Target)
				setMoveType(EMoveType.Not_Set);
		} else
			player.sendMessage("InertiaMode PartyTarget changed to -> [" + _assistPassport.getPlayerName() + "]");
	}

	public void setAutoAttack(final EAutoAttack autoAttack)
	{
		if (autoAttack == _autoAttack)
			return;
		_autoAttack = autoAttack;
		final var player = getActivePlayer();
		player.sendMessage("InertiaMode AttackType changed to -> [" + _autoAttack + "]");
	}

	public void setMoveType(EMoveType moveType)
	{
		final var player = getActivePlayer();
		if (moveType == EMoveType.Current_Location)
		{
			_lastSavedLocation = new Location(player.getLocation());
			player.sendMessage("Updated search location to current position.");
			moveType = EMoveType.Saved_Location;
		}
		renderRange();
		if (moveType == _moveType)
			return;
		_moveType = moveType;
		player.sendMessage("InertiaMode MoveType changed to -> [" + _moveType + "]");
		renderRange();
	}

	public void setSearchTarget(final ESearchType searchType)
	{
		if (searchType == _searchType)
			return;
		_searchType = searchType;
		final var player = getActivePlayer();
		player.sendMessage("InertiaMode SearchType changed to -> [" + _searchType + "]");
		renderRange();
	}

	private static final String STOPPED = "<td align=center><button value=\"Start\" action=\"bypass inertia_start %d\" width=70 height=22 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td><td align=center><font name=hs12 color=\"FF6363\">Stopped</font></td>";
	private static final String RUNNING = "<td align=center><font name=hs12 color=\"63FF63\">Running</font></td><td align=center><button value=\"Stop\" action=\"bypass inertia_stop %d\" width=70 height=22 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td>";

	public void render(L2PcInstance viewer)
	{
		final var player = getActivePlayer();
		if (player != null)
		{
			final var npcHtml = new NpcHtmlMessage();
			npcHtml.setFile(player, "data/html/aepvp/inertiax/main.htm");
			// state

			final String running = String.format(_running ? RUNNING : STOPPED, _ownerId);

			npcHtml.replace("%state%", running);
			npcHtml.replace("%attack%", buildAutoAttack());
			npcHtml.replace("%move%", buildMoveType());
			npcHtml.replace("%party%", buildParty());
			npcHtml.replace("%opt%", buildOptions());
			npcHtml.replace("%search%", buildSearch());
			npcHtml.replace("%time%", buildTime());
			npcHtml.replace("%ask%", buildActions(_inertiaSkills));

			npcHtml.replace("%id%", _ownerId);
			npcHtml.replace("%name%", player.getName());
			viewer.sendPacket(npcHtml);
		}
	}

	public void render()
	{
		final var player = getActivePlayer();
		if (player != null)
		{
			render(player);
		}
	}

	private String buildTime()
	{
		final long hours = _remainingTicks / 3_600_000;
		final long minutes = (_remainingTicks - (3_600_000 * hours)) / 60_000;
		final long seconds = _remainingTicks - hours * 3_600_000 - minutes * 60_000;
		return String.format("%02d Hours %02d Minutes %02d Seconds", hours, minutes, seconds / 1000);
	}

	private String buildAutoAttack()
	{
		final var eattackTypes = EAutoAttack.values();
		final List<EAutoAttack> attackTypes = new ArrayList<>(eattackTypes.length);
		for (final var eattackType : eattackTypes)
			if (eattackType != _autoAttack)
				attackTypes.add(eattackType);
		String ret = _autoAttack.toString();
		for (final var attackType : attackTypes)
			ret += ";" + attackType;
		return ret;
	}

	private String buildMoveType()
	{
		final var emoveTypes = EMoveType.values();
		final List<EMoveType> moveTypes = new ArrayList<>(emoveTypes.length);
		for (final var emoveType : emoveTypes)
			if (emoveType != _moveType)
				moveTypes.add(emoveType);
		String ret = _moveType.toString();
		for (final var moveType : moveTypes)
		{
			if (moveType == EMoveType.Saved_Location && _lastSavedLocation == null)
				continue;
			if (moveType != EMoveType.Follow_Target || _assistPassport != null)
				ret += ";" + moveType;
		}
		ret = ret.replace("Target", _assistPassport == null ? "Target" : _assistPassport.getPlayerName());
		return ret;
	}

	private String buildParty()
	{
		final var player = getActivePlayer();
		final var party = player.getParty();
		if (party == null)
			return "Not Set";
		String ret = _assistPassport == null ? "Not Set" : _assistPassport.getPlayerName() + ";Not Set";
		for (final var member : party.getPartyMembers())
		{
			final var memberPassport = member.getPassport();
			if (memberPassport != _assistPassport && memberPassport != _playerPassport)
				ret += ";" + member.getName();
		}
		return ret;
	}
	
	private static final String search = "<td align=center width=50><button value=\"%s\" action=\"bypass inertia_search_type %d %s\" width=62 height=22 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td>";
	private static final String searcs = "<td align=center width=50><font name=hs12 color=\"%s\">%s</font></td>";

	private String buildSearch()
	{
		final StringBuilder sb = new StringBuilder(512);
		for (final var esearch : ESearchType.values())
		{
			if (esearch == _searchType)
				sb.append(String.format(searcs, esearch.getColor(), esearch.toString(), esearch.toString()));
			else
				sb.append(String.format(search, esearch.toString(), _ownerId, esearch.toString()));
		}
		return sb.toString();
	}

	private String buildOptions()
	{
		String opts = "";
		for (final var opt : EPanelOption.values())
			opts += opt.toString() + ";";
		return opts;
	}

	private static final String actionTemplate = "<td align=center width=50><table height=34 cellspacing=0 cellpadding=0 background=%s><tr><td><table cellspacing=0 cellpadding=0><tr><td><button action=\"bypass inertia_action_edit %d %s\" width=34 height=34 back=L2UI_CH3.menu_outline_Down fore=L2UI_CH3.menu_outline></td></tr></table></td></tr></table></td>";

	private String buildActions(final InertiaCast[] inertiaActions)
	{
		final StringBuilder sb = new StringBuilder(1024);
		int aid = 0;
		for (final var inertiaAction : inertiaActions)
		{
			if (inertiaAction != null)
				sb.append(String.format(actionTemplate, inertiaAction.getIcon(), _ownerId, String.valueOf(aid++)));
			else
				sb.append(String.format(actionTemplate, "L2UI_CT1.Inventory_DF_CloakSlot_Disable", _ownerId, String.valueOf(aid++)));
		}
		return sb.toString();
	}

	public boolean toggleFilteredTarget(final L2PcInstance viewer, final int npcTemplateId)
	{
		final var panel = fetchPanel(EPanelOption.Target_Filter);
		if (panel instanceof TargetFiltering targetFiltering)
			return targetFiltering.toggleFilteredId(npcTemplateId);
		return false;
	}

	public void renderActionEdit(final int slot, final int page)
	{
		final int SKILLS_PER_PAGE = 9;
		final var npcHtml = new NpcHtmlMessage();
		npcHtml.setFile(getActivePlayer(), "data/html/aepvp/inertiax/skill.htm");
		final StringBuilder sb = new StringBuilder();
		npcHtml.replace("%tit%", "Inertia Action " + slot);
		final var player = getActivePlayer();
		final ArrayList<L2Skill> availSkills = new ArrayList<>();
		for (final var skill : player.getAllSkills())
		{
			if (skill.isActive() && !skill.isToggle() && skill.isInertiaAllow())
				availSkills.add(skill);
		}
		final int skillsLen = availSkills.size();
		for (int i = 0; i < SKILLS_PER_PAGE; i++)
		{
			final int indx = SKILLS_PER_PAGE * page + i;
			if (indx < skillsLen)
			{
				final var skill = availSkills.get(indx);
				sb.append(String.format(actionTemplate.replace("inertia_action_edit", "inertia_action_set"), skill.getIcon(), _ownerId, slot + " " + skill.getId()));
			}
		}
		npcHtml.replace("%ask%", sb.toString());
		// pages
		final int pages = skillsLen < SKILLS_PER_PAGE ? 1 : skillsLen / SKILLS_PER_PAGE + ((skillsLen % SKILLS_PER_PAGE) > 0 ? 1 : 0);
		sb.setLength(0);
		for (int i = 0; i < pages; i++)
		{
			if (page == i)
				sb.append(String.format("<td align=center>Page %d</td>", i + 1));
			else
				sb.append(String.format("<td align=center><a action=\"bypass inertia_action_edit %d %d %d\">Page %d</a></td>", _ownerId, slot, i, i + 1));
		}
		npcHtml.replace("%pages1%", sb.toString());
		//
		final var action = _inertiaSkills[slot];
		if (action != null)
		{
			final var skill = SkillTable.getInstance().getInfoLevelMax(action.getActionId());
			npcHtml.replace("%sic%", skill.getIcon());
			npcHtml.replace("%sna%", skill.getName());
			npcHtml.replace("%reu%", String.format("%.2fs", action.getReuse()));
			npcHtml.replace("%hpp%", String.format("%05.2f%%", action.getUserHp()));
			npcHtml.replace("%tpp%", String.format("%05.2f%%", action.getTargetHp()));
			final var epriorities = EActionPriority.values();
			final var priority = epriorities[slot];
			String spr = priority.toString();
			for (final var pr : epriorities)
				if (pr != priority)
					spr += ";" + pr.toString();
			npcHtml.replace("%pr%", spr);
		} else
		{
			npcHtml.replace("%sic%", "L2UI_CT1.Inventory_DF_CloakSlot_Disable");
			npcHtml.replace("%sna%", "Empty");
			npcHtml.replace("%reu%", "?");
			npcHtml.replace("%hpp%", "?");
			npcHtml.replace("%tpp%", "?");
			npcHtml.replace("%pr%", "");
		}
		npcHtml.replace("%priority%", slot + 1);
		npcHtml.replace("%slot%", slot);
		npcHtml.replace("%id%", _ownerId);
		player.sendPacket(npcHtml);
	}

	private void renderRange()
	{
		final var player = getActivePlayer();
		if ((player instanceof Ghost) || player == null)
			return;
		final int searchRange = _searchType.getRange();
		final ILocational renderLoc = _moveType == EMoveType.Saved_Location ? _lastSavedLocation : player;
		final ExServerPrimitive renderRange = new ExServerPrimitive("SearchRange", renderLoc);
		if ((_moveType != EMoveType.Follow_Target) && (searchRange > 1))
		{
			final var color = _running ? Color.GREEN : Color.RED;
			renderRange.addCircle(color, searchRange, 30, -20);
			renderRange.addCircle(color, 5, 4, -20);
		} else
			renderRange.addCircle(Color.GREEN, 1, 1, -5);
		player.sendPacket(renderRange);
	}

	public boolean isRunning()
	{
		return _running;
	}

	public void setRunning(final boolean running)
	{
		_running = running;
		renderRange();
	}

	public L2Character getTargetAssist()
	{
		return null;
	}

	public L2Character getTargetRange(final int range)
	{
		return null;
	}

	public ESearchType getSearchType()
	{
		return _searchType;
	}

	public VTargetFilter getVTargetFilter()
	{
		return _vtargetFilter;
	}

	public int getOwnerId()
	{
		return _ownerId;
	}

	public void onItemDrop(final int itemId, final long count)
	{
		if (_running)
		{
			final var inertiaPanel = fetchPanel(EPanelOption.Drops_Tracker);
			if (inertiaPanel instanceof DropTracker dropTracker)
				dropTracker.insertDrop(itemId, count);
		}
	}

	public void renderPanel(final EPanelOption panelOption, final L2PcInstance viewer)
	{
		final var panel = fetchPanel(panelOption);
		panel.render(viewer);
	}

	public InertiaPanel getPanel(final EPanelOption panelOption)
	{
		return _panels.get(panelOption);
	}

	public InertiaPanel fetchPanel(final EPanelOption panelOption)
	{
		return _panels.computeIfAbsent(panelOption, p -> p.getCompute().apply(this));
	}

	private void evt(final EInertiaEvt inertiaEvt)
	{
		_inertiaAct.evt(inertiaEvt);
	}

	public void addInertiaExt(final InertiaExt inertiaExt)
	{
		_inertiaAct.addInertiaExt(inertiaExt);
	}
}

</C:\l2sq\assets\autofarm\src\model\Inertia.java>
</Inertia.java>
<InertiaAct.java>
<C:\l2sq\assets\autofarm\src\model\InertiaAct.java>
package inertiax.model;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicLong;

import inertiax.enums.IInertiaCmd;
import inertiax.enums.IInertiaCmd.EInertiaEvt;
import inertiax.model.ext.InertiaExt;
import inertiax.model.ext.InertiaExt.EActResult;
import l2.ae.pvp.gameserver.model.actor.L2Character;
import l2.ae.pvp.gameserver.model.actor.instance.L2PcInstance;

public class InertiaAct
{
	private HashMap<IInertiaCmd, AtomicLong> _evtLags;
	
	private LinkedList<InertiaExt> _inertiaExts;
	
	private L2Character _target = null;
	private L2PcInstance _assistPlayer = null;
	private int _lag;
	
	private boolean _exit;
	
	protected final Inertia _inertia;
	
	public InertiaAct(final Inertia inertia)
	{
		_inertia = inertia;
	}
	
	public void addCmdLag(final IInertiaCmd inertiaCmd, final long addLag)
	{
		if (_evtLags == null)
			_evtLags = new HashMap<>();
		
		final AtomicLong lag = _evtLags.computeIfAbsent(inertiaCmd, eact -> new AtomicLong());
		
		lag.addAndGet(addLag);
	}
	
	public boolean hasCmdLag(final IInertiaCmd inertiaCmd)
	{
		if (_evtLags == null)
			return false;
		return _evtLags.containsKey(inertiaCmd);
	}
	
	public void tick(final long tick)
	{
		if (_evtLags != null)
			_evtLags.values().removeIf((al) -> al.addAndGet(-tick) < 1);
	}
	
	protected void reset()
	{
		_target = null;
		_assistPlayer = null;
		_lag = 0;
		_exit = false;
	}
	
	public void setTarget(final L2Character target)
	{
		_target = target;
	}
	
	public L2Character getTarget()
	{
		return _target;
	}
	
	public void setAssistPlayer(final L2PcInstance assistPlayer)
	{
		_assistPlayer = assistPlayer;
	}
	
	public L2PcInstance getAssistPlayer()
	{
		return _assistPlayer;
	}
	
	public int getInertiaLag()
	{
		return _lag;
	}
	
	public void addInertiaLag(final int lag)
	{
		_lag += lag;
	}
	
	private void exit()
	{
		_exit = true;
	}
	
	public void addInertiaExt(final InertiaExt inertiaExt)
	{
		if (_inertiaExts == null)
			_inertiaExts = new LinkedList<>();
		_inertiaExts.add(inertiaExt);
	}
	
	protected void evt(final EInertiaEvt inertiaEvt)
	{
		preprocessEvt(inertiaEvt);
		
		if (_exit)
			return;
		
		if (_inertiaExts != null && !hasCmdLag(inertiaEvt))
		{
			for (final InertiaExt inertiaExt : _inertiaExts)
			{
				final LinkedList<IInertiaCmd> triggerActs = inertiaEvt.getCmdTriggers();
				
				for (final IInertiaCmd inertiaCmd : triggerActs)
				{
					if (!hasCmdLag(inertiaCmd))
					{
						final EActResult actResult = inertiaExt.actExt(inertiaCmd, InertiaAct.this);
						
						switch (actResult)
						{
							case ACT__EXIT:
								exit();
							case ACT__BREAK:
								return;
						}
					}
				}
			}
		}
	}
	
	private void preprocessEvt(final EInertiaEvt inertiaEvt)
	{
		switch (inertiaEvt)
		{
			case EVT__START:
				onStart();
				return;
			case EVT__END:
				onEnd();
				return;
		}
	}
	
	public Inertia getInertia()
	{
		return _inertia;
	}
	
	public L2PcInstance getActivePlayer()
	{
		return _inertia.getActivePlayer();
	}
	
	private void onStart()
	{
		
	}
	
	private void onEnd()
	{
		_inertia.addLag(_lag);
		reset();
	}
	
}

</C:\l2sq\assets\autofarm\src\model\InertiaAct.java>
</InertiaAct.java>
<PlayerExt.java>
<C:\l2sq\assets\autofarm\src\model\ext\PlayerExt.java>
package inertiax.model.ext;

import inertiax.enums.IInertiaCmd.EInertiaEvt;
import inertiax.model.Inertia;
import inertiax.model.InertiaAct;
import l2.ae.pvp.gameserver.ai.CtrlIntention;
import l2.ae.pvp.gameserver.model.actor.L2Character;
import l2.ae.pvp.gameserver.model.actor.instance.L2PcInstance;
import l2.ae.pvp.gameserver.network.serverpackets.MyTargetSelected;

public class PlayerExt extends InertiaExt
{
	@Override
	protected void initExt()
	{
		register(EInertiaEvt.EVT__ATK_TARGET, this::atkTarget);
		register(EInertiaEvt.EVT__REM_TARGET, this::remTarget);
		register(EInertiaEvt.EVT__NEW_TARGET, this::newTarget);
		

		register(EInertiaEvt.EVT__CREDIT_END, this::creditsEnd);

		register(EInertiaEvt.EVT__WHILE_TARGET_DEAD, this::whileTargetDead);
		register(EInertiaEvt.EVT__WHILE_DEAD, this::whileDead);

		register(EInertiaEvt.EVT__FOLLOW_CLOSE, this::onFollowClose);
		register(EInertiaEvt.EVT__FOLLOW_FAR, this::onFollowFar);

		register(EInertiaEvt.EVT__ASSIST_NO_TARGET, this::onAssistNoTarget);

		super.initExt();
	}
	
	private EActResult atkTarget(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		final L2Character actualTarget = inertiaAct.getTarget();
		
		if (player != null && player != actualTarget && actualTarget.isAutoAttackable(player))
			player.getAI().setIntention(CtrlIntention.AI_INTENTION_ATTACK, actualTarget);
		
		return EActResult.ACT__CONTINUE;
	}
	
	private EActResult remTarget(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		if (player.isCastingNow())
			player.breakCast();
		if (player.isAttackingNow())
			player.breakAttack();
		player.setTarget(null);

		return EActResult.ACT__CONTINUE;
	}
	
	private EActResult newTarget(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		final L2Character newTarget = inertiaAct.getTarget();
		
		player.setTarget(newTarget);
		player.sendPacket(new MyTargetSelected(player, newTarget));
		
		return EActResult.ACT__CONTINUE;
	}

	private EActResult whileTargetDead(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		player.setTarget(null);
		
		return EActResult.ACT__CONTINUE;
	}
	
	private EActResult whileDead(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		final Inertia inertia = inertiaAct.getInertia();
		
		if (player.isRealPlayer())
			inertia.setRunning(false);
		
		return EActResult.ACT__CONTINUE;
	}
	
	private EActResult creditsEnd(final InertiaAct inertiaAct)
	{
		final Inertia inertia = inertiaAct.getInertia();
		inertia.setRunning(false);
		inertia.render();
		
		return EActResult.ACT__EXIT;
	}
	
	private EActResult onFollowClose(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		player.getAI().setIntention(CtrlIntention.AI_INTENTION_ACTIVE);	

		return EActResult.ACT__EXIT;
	}
	
	private EActResult onFollowFar(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		final L2PcInstance assistPlayer = inertiaAct.getAssistPlayer();
		
		player.getAI().setIntention(CtrlIntention.AI_INTENTION_FOLLOW, assistPlayer);

		return EActResult.ACT__EXIT;
	}
	
	private EActResult onAssistNoTarget(final InertiaAct inertiaAct)
	{
		final L2PcInstance player = inertiaAct.getActivePlayer();
		
		final L2PcInstance assistPlayer = inertiaAct.getAssistPlayer();
		
		player.setTarget(assistPlayer);
		player.sendPacket(new MyTargetSelected(player, assistPlayer));

		return EActResult.ACT__EXIT;
	}

}

</C:\l2sq\assets\autofarm\src\model\ext\PlayerExt.java>
</PlayerExt.java>
<IInertiaBehave.java>
<C:\l2sq\assets\autofarm\src\model\IInertiaBehave.java>
package inertiax.model;

import l2.ae.pvp.gameserver.model.L2Skill;
import l2.ae.pvp.gameserver.model.actor.L2Character;
import l2.ae.pvp.gameserver.model.actor.instance.L2PcInstance;

public interface IInertiaBehave
{
//	public void setAutoChill(final Inertia autoChill);
	
	public default void expand(IInertiaBehave behave)
	{
		
	}
	
	void onThinkStart();
	
	void onThinkEnd();
	
	void onDeath(L2Character killer);
	
	void onKill(L2Character victim);
	
	void onAttack(L2Character target);
	
	void onSkillCast(L2Skill skill);
	
	void onNewTarget(L2Character oldTarget, L2Character newTarget);
	
	boolean filterSkill(L2Skill skill);
	
	boolean filterTarget(L2Character target);
	
	void whileDead();
	
	void whileTargetDead();
	
	void onCreditsEnd();
	
	float lagMultiplier();
	
	void onUntarget();

	void onFollowClose(L2PcInstance assistPlayer);

	void onFollowFar(L2PcInstance assistPlayer);

	void onAssistNoTarget(L2PcInstance assistPlayer);

	void onStartAutoAttack(L2Character actualTarget);
	
	public void setInertia(final Inertia inertia);
	
	public Inertia getInertia();
	
	public default int getPriority()
	{
		return 0;
	}
	
	public L2Character searchTarget();
	
	public void onNoTargetFound();
}
</C:\l2sq\assets\autofarm\src\model\IInertiaBehave.java>
</IInertiaBehave.java>
<EAutoAttack.java>
<C:\l2sq\assets\autofarm\src\enums\EAutoAttack.java>
package inertiax.enums;

public enum EAutoAttack
{
	Never,
	Always,
	Skills_Reuse;
	
	@Override
	public String toString()
	{
		return super.toString().replace('_', ' ');
	}

}

</C:\l2sq\assets\autofarm\src\enums\EAutoAttack.java>
</EAutoAttack.java>
<EMoveType.java>
<C:\l2sq\assets\autofarm\src\enums\EMoveType.java>
package inertiax.enums;

public enum EMoveType
{
	Not_Set,
	Follow_Target,
	Current_Location,
	Saved_Location;
	
	@Override
	public String toString()
	{
		return super.toString().replace('_', ' ');
	}

}

</C:\l2sq\assets\autofarm\src\enums\EMoveType.java>
</EMoveType.java>
<ESearchType.java>
<C:\l2sq\assets\autofarm\src\enums\ESearchType.java>
package inertiax.enums;


public enum ESearchType
{
	Off("FF6363"),
	Assist("LEVEL"),
	Close("63FF63"),
	Near("63FF63"),
	Far("63FF63");

	private final String _color;

	private ESearchType(final String color)
	{
		_color = color;
	}
	
	public String getColor()
	{
		return _color;
	}
	
	public int getRange()
	{
		switch (this)
		{
			case Off:
				return -1;
			case Assist:
				return 0;
			case Close:
				return 400;
			case Near:
				return 2000;
			case Far:
				return 3000;
		}
		return 0;
	}
}

</C:\l2sq\assets\autofarm\src\enums\ESearchType.java>
</ESearchType.java>
<EPanelOption.java>
<C:\l2sq\assets\autofarm\src\enums\EPanelOption.java>
package inertiax.enums;

import java.util.function.Function;

import inertiax.model.Inertia;
import inertiax.model.InertiaPanel;
import inertiax.model.panels.DropTracker;
import inertiax.model.panels.PathEditor;
import inertiax.model.panels.RangeEditor;
import inertiax.model.panels.TargetFiltering;
import l2.ae.pvp.gameserver.model.actor.instance.L2PcInstance;

public enum EPanelOption
{
	Target_Filter(TargetFiltering::new),
	Drops_Tracker(DropTracker::new),
	Range_Editor(RangeEditor::new),
//	Activity_Stats(TargetFiltering::new),
//	InertiaX_Info(TargetFiltering::new),
	Path_Editor(PathEditor::new),
	;
	
	private final Function<Inertia, InertiaPanel> _panelSupplier;
	
	private EPanelOption(final Function<Inertia, InertiaPanel> panelSupplier)
	{
		_panelSupplier = panelSupplier;
	}
	
	@Override
	public String toString()
	{
		return (ordinal() + 1) + " " + super.toString().replace('_', ' ');
	}

	public void render(final Inertia inertia, final L2PcInstance player)
	{
		final InertiaPanel inertiaPanel = inertia.fetchPanel(this);
		inertiaPanel.render(player);
	}
	
	public Function<Inertia, InertiaPanel> getCompute()
	{
		return _panelSupplier;
	}
	
	public String toLowerCase()
	{
		return super.toString().toLowerCase();
	}
}

</C:\l2sq\assets\autofarm\src\enums\EPanelOption.java>
</EPanelOption.java>
<main.htm>
<C:\l2sq\Pac Project\build\dist-dev\gameserver\data\html\scripts\services\community\autofarm\main.htm>
size=400x420size_end
<html noscrollbar="1">
   <title>Inertia (%name%)</title>
   <body>
      <center>
	  
		<br>
		 
		<table background="l2ui_ct1.Windows_DF_TooltipBG" cellspacing=1 cellpadding=1 width=100%>
			 <tr>
               <td align=center width=100%>
                  <font name="hs12" color="e3e3e3">Status</font>
               </td>
            </tr>
			<tr>
				<td align=center>
					<table align=center width=100% cellspacing=2 cellpadding=2>
						
						<tr>
							<td><img width=70 /></td>
							<td><img width=70 /></td>
							<td><img width=70 /></td>
							<td><img width=70 /></td>
							
						</tr>
						
					    <tr>
						   %state%
						   <td align=center>
							  <button value="Refresh" action="bypass inertia_refresh %id%" width=70 height=22 back="L2UI_ct1.button_df" fore="L2UI_ct1.button_df">
						   </td>
						   <td align=center>
							  <button value="Reset" action="bypass inertia_reset %id%" width=70 height=22 back="L2UI_ct1.button_df" fore="L2UI_ct1.button_df">
						   </td>
						</tr>
						
					</table>
				</td>
			</tr>
			
			
			<tr>
				<td align=center>
					<font color="e3e3e3">Time Left </font>
					<font color="d2a679">%time%</font>
				</td>
			</tr>

			<tr>
				<td><img height=5/></td>
			</tr>

         </table>
	    
		<br>

         <table background="l2ui_ct1.Windows_DF_TooltipBG" width=100% height=60>
			<tr>
				<td align=center width=100%>
                  <font name="hs12" color="e3e3e3">Behavior</font>
                </td>

			</tr>
			<tr>
				<td>
					<table width=100%>
					    <tr>
						   <td align=center>
							  <font color="e3e3e3">Auto Attack: </font>
						   </td>
						   <td align=center>
							  <combobox width=135 var="target" list="%attack%">
						   </td>
						   <td align=center>
							  <button value="Set" action="bypass inertia_attack_type %id% $target" width=60 height=22 back="L2UI_ct1.button_df" fore="L2UI_ct1.button_df">
						   </td>
						</tr>
						<tr>
						   <td align=center>
							  <font color="e3e3e3">Party Target: </font>
						   </td>
						   <td align=center>
							  <combobox width=135 var="party" list="%party%">
						   </td>
						   <td align=center>
							  <button value="Set" action="bypass inertia_party_target %id% $party" width=60 height=22 back="L2UI_ct1.button_df" fore="L2UI_ct1.button_df">
						   </td>
						</tr>
						<tr>
						   <td align=center>
							  <font color="e3e3e3">Movement: </font>
						   </td>
						   <td align=center>
							  <combobox width=135 var="move" list="%move%">
						   </td>
						   <td align=center>
							  <button value="Set" action="bypass inertia_move_type %id% $move" width=60 height=22 back="L2UI_ct1.button_df" fore="L2UI_ct1.button_df">
						   </td>
						</tr>
						<tr>
						   <td align=center>
							  <font color="e3e3e3">More Options: </font>
						   </td>
						   <td align=center>
							  <combobox width=135 var="opt" list="%opt%">
						   </td>
						   <td align=center>
							  <button value="Open" action="bypass inertia_render_panel %id% $opt" width=60 height=22 back="L2UI_ct1.button_df" fore="L2UI_ct1.button_df">
						   </td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td><img height=5/></td>
			</tr>
         </table>
		 
		 <br>

         <table width=100% background="l2ui_ct1.Windows_DF_TooltipBG" cellspacing=2 cellpadding=2>
             <tr>
              <td align=center width=100%>
                  <font name="hs12" color="e3e3e3">Targeting</font>
               </td>
            </tr>
			<tr>
				<td>
				
					<table width=100% align=center>
					
						<tr>
							%search%
						</tr>
			
					</table>
				
				</td>
			
			</tr>
			<tr>
				<td><img height=5/></td>
			</tr>
         </table>
         <br>
		 
         <table width=100%>
			<tr>
				<td>
				
					<table width=100% background="l2ui_ct1.Windows_DF_TooltipBG">
					
						<tr>
						   <td align=center width=100%>
							  <font name="hs12" color="e3e3e3">Auto Skill</font>
						   </td>
						</tr>
						<tr>
							<td>
								<table>
									<tr>
										%ask%
									</tr>
									<tr>
										<td><img height=5 /></td>
									</tr>
									<tr>
										<td align=center><font name=hs10 color=LEVEL>1</font></td>
										<td align=center><font name=hs10 color=LEVEL>2</font></td>
										<td align=center><font name=hs10 color=LEVEL>3</font></td>
										<td align=center><font name=hs10 color=LEVEL>4</font></td>
										<td align=center><font name=hs10 color=LEVEL>5</font></td>
										<td align=center><font name=hs10 color=LEVEL>6</font></td>
										<td align=center><font name=hs10 color=LEVEL>7</font></td>
									</tr>
								</table>
							</td>
						</tr>
						<tr>
							<td><img height=5/></td>
						</tr>
					
					
					</table>
				
				</td>
				<td><img width=1/></td>
				
			</tr>
         </table>
		 
		 <br>
		 


      </center>
   </body>
</html>
</C:\l2sq\Pac Project\build\dist-dev\gameserver\data\html\scripts\services\community\autofarm\main.htm>
</main.htm>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\GameObject.java>
// ============================================================================
// ====================== MINIMIZED GameObject.java ===========================
// ============================================================================
package l2ft.gameserver.model;

import l2ft.commons.lang.reference.HardReference;
import l2ft.commons.lang.reference.HardReferences;
import l2ft.gameserver.utils.Location;

/**
 * Minimized abstract GameObject for our MVP.
 * Parent of Creature, Player, Summon, etc.
 */
public abstract class GameObject
{
    protected int objectId;
    protected boolean _isVisible;

    // Basic position
    protected int _x, _y, _z;

    public GameObject(int objectId)
    {
        this.objectId = objectId;
    }

    // For references
    public HardReference<? extends GameObject> getRef()
    {
        return HardReferences.emptyRef();
    }
    public int getObjectId()
    {
        return objectId;
    }

    public boolean isVisible()
    {
        return _isVisible;
    }
    public void setVisibility(boolean val)
    {
        _isVisible = val;
    }

    /** Basic coordinates. */
    public int getX() { return _x; }
    public int getY() { return _y; }
    public int getZ() { return _z; }

    public Location getLoc()
    {
        return new Location(_x, _y, _z);
    }

    /** Basic teleporter. Omitted advanced reflection. */
    public void setLoc(Location loc)
    {
        _x = loc.x;
        _y = loc.y;
        _z = loc.z;
    }

    /** Placeholder for “decay” or “delete” logic. */
    public void deleteMe() { }

    /** Generic is-something checks. */
    public boolean isCreature() { return false; }
    public boolean isPlayable() { return false; }
    public boolean isPlayer()   { return false; }
    public boolean isMonster()  { return false; }
    public boolean isItem()     { return false; }
    public boolean isSummon()   { return false; }

    @Override
    public String toString()
    {
        return getClass().getSimpleName() + ":" + objectId;
    }
}
// ============================================================================
// ==================== END MINIMIZED GameObject.java =========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\GameObject.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Playable.java>
// ============================================================================
// ======================= MINIMIZED Playable.java ============================
// ============================================================================
package l2ft.gameserver.model;

import l2ft.commons.lang.reference.HardReference;
import l2ft.gameserver.templates.CharTemplate;

/**
 * Minimized Playable class:
 * Parent class for Player and Summon.
 */
public abstract class Playable extends Creature
{
    // Some flags or references
    private boolean _isPendingRevive;

    public Playable(int objectId, CharTemplate template)
    {
        super(objectId, template);
    }

    @SuppressWarnings("unchecked")
    @Override
    public HardReference<? extends Playable> getRef()
    {
        return (HardReference<? extends Playable>) super.getRef();
    }

    /** Is this playable pending a “revive” (like wait for accept)? */
    public void setPendingRevive(boolean value)
    {
        _isPendingRevive = value;
    }
    public boolean isPendingRevive()
    {
        return _isPendingRevive;
    }

    /**
     * Called to “fully” revive this playable.
     * Minimally, we just restore some HP here or do watchers.
     */
    @Override
    public void doRevive()
    {
        if (!isTeleporting())
        {
            setPendingRevive(false);
            // Minimal: simply set HP to something
            setCurrentHp(Math.max(1, getMaxHp()));
        }
        else
            setPendingRevive(true);
    }

    /** For picking up items, overridden in Player or Summon. */
    public abstract void doPickupItem(GameObject object);

    /** For sitting or standing. Overridden in Player. */
    public void sitDown(StaticObjectInstance throne) { }
    public void standUp() { }

    /** Basic checks for controlling or auto-attack logic. */
    public boolean isCtrlAttackable(Creature attacker, boolean force, boolean withCtrl)
    {
        // Minimally returns false; real code is in Player / Summon
        return false;
    }

    @Override
    public boolean isPlayable()
    {
        return true;
    }
}
// ============================================================================
// ===================== END MINIMIZED Playable.java ==========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Playable.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Summon.java>
// ============================================================================
// ======================== MINIMIZED Summon.java =============================
// ============================================================================
package l2ft.gameserver.model;

import l2ft.gameserver.ai.SummonAI;
import l2ft.gameserver.network.l2.s2c.NpcInfo;
import l2ft.gameserver.network.l2.s2c.PetInfo;
import l2ft.gameserver.templates.npc.NpcTemplate;

/**
 * Minimized Summon class for our MVP.
 * Summon extends Playable, used by Player.
 */
public abstract class Summon extends Playable
{
    protected Player _owner;
    protected boolean _follow = true; // is following owner?

    public Summon(int objectId, NpcTemplate template, Player owner)
    {
        super(objectId, template);
        _owner = owner;
    }

    public abstract int getSummonType();

    @Override
    public Player getPlayer()
    {
        return _owner;
    }

    @Override
    public SummonAI getAI()
    {
        // Minimally, we can return a new SummonAI or null
        if(_ai == null)
            _ai = new SummonAI(this);
        return (SummonAI) _ai;
    }

    public boolean isDepressed()
    {
        return false;
    }

    @Override
    public void doPickupItem(GameObject object)
    {
        // Summons generally can't pick up items
    }

    @Override
    public int getKarma()
    {
        // Summon uses owner's karma
        Player owner = getPlayer();
        return owner == null ? 0 : owner.getKarma();
    }

    @Override
    public boolean isSummon()
    {
        return true;
    }

    /** 
     * Basic broadcast info for Summon. 
     * Typically PetInfo, NpcInfo, etc. 
     */
    public void broadcastCharInfo()
    {
        // Minimal
        if (!isVisible())
            return;
        getPlayer().sendPacket(new PetInfo(this));
        for (Player p : World.getAroundPlayers(this))
            p.sendPacket(new NpcInfo(this, p));
    }
}
// ============================================================================
// ====================== END MINIMIZED Summon.java ===========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Summon.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Party.java>
// ============================================================================
// ========================= MINIMIZED Party.java =============================
// ============================================================================
package l2ft.gameserver.model;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import l2ft.gameserver.network.l2.s2c.SystemMessage;
import l2ft.gameserver.network.l2.s2c.SystemMessage2;
import l2ft.gameserver.utils.Location;

/**
 * Minimized Party class for our MVP. 
 * - Basic add/remove members
 * - Basic broadcast logic
 * - Basic "party level", "loot distribution" fields, etc.
 */
public class Party implements PlayerGroup
{
    public static final int MAX_SIZE = 9;
    public static final int ITEM_LOOTER = 0;
    public static final int ITEM_RANDOM = 1;
    public static final int ITEM_RANDOM_SPOIL = 2;
    public static final int ITEM_ORDER = 3;
    public static final int ITEM_ORDER_SPOIL = 4;

    private final List<Player> _members = new CopyOnWriteArrayList<>();
    private int _partyLvl;
    private int _itemDistribution;

    public Party(Player leader, int itemDistribution)
    {
        _itemDistribution = itemDistribution;
        _members.add(leader);
        _partyLvl = leader.getLevel();
    }

    public List<Player> getPartyMembers()
    {
        return _members;
    }

    public int getMemberCount()
    {
        return _members.size();
    }

    public boolean isLeader(Player player)
    {
        return ! _members.isEmpty() && _members.get(0) == player;
    }

    public Player getPartyLeader()
    {
        if(_members.isEmpty())
            return null;
        return _members.get(0);
    }

    public boolean addPartyMember(Player player)
    {
        if(_members.size() >= MAX_SIZE)
            return false;
        if(_members.contains(player))
            return false;
        _members.add(player);
        player.setParty(this);
        recalculatePartyData();
        return true;
    }

    public boolean removePartyMember(Player player, boolean kick)
    {
        boolean removed = _members.remove(player);
        if(removed)
        {
            player.setParty(null);
            recalculatePartyData();
        }
        return removed;
    }

    public void dissolveParty()
    {
        for(Player p : _members)
        {
            p.sendPacket(SystemMessage2.removeObjects());
            p.setParty(null);
        }
        _members.clear();
    }

    /** Minimal recalc logic. */
    public void recalculatePartyData()
    {
        int highest = 1;
        for (Player p : _members)
            highest = Math.max(highest, p.getLevel());
        _partyLvl = highest;
    }

    public int getLevel()
    {
        return _partyLvl;
    }

    public int getLootDistribution()
    {
        return _itemDistribution;
    }

    @Override
    public void broadCast(IStaticPacket... packets)
    {
        for(Player member : _members)
            member.sendPacket(packets);
    }

    /** Teleports the entire party to a given location. */
    public void Teleport(Location loc)
    {
        for(Player member : _members)
            member.teleToLocation(loc);
    }

    /** Summarily for referencing. */
    public boolean isInCommandChannel()
    {
        return false;
    }

    /** Broadcasting a SystemMessage to the entire party. */
    public void broadcastToPartyMembers(Player exclude, SystemMessage msg)
    {
        for (Player member : _members)
            if (member != exclude)
                member.sendPacket(msg);
    }
}
// ============================================================================
// ======================= END MINIMIZED Party.java ===========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Party.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\Formulas.java>
// ============================================================================
// ======================= MINIMIZED Formulas.java ============================
// ============================================================================
package l2ft.gameserver.stats;

import l2ft.commons.util.Rnd;
import l2ft.gameserver.Config;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.model.base.Element;
import l2ft.gameserver.model.base.SkillTrait;

/**
 * Minimized Formulas class for MVP:
 * - Basic calculations for physical/magic damage, crit, etc.
 * - We skip lethal, synergy, special logic.
 */
public class Formulas
{
    /**
     * Basic physical damage calculation for the MVP.
     * We omit many advanced rules, just do a simplified approach:
     */
    public static double calcPhysDam(Creature attacker, Creature target, Skill skill, boolean ss)
    {
        if(attacker == null || target == null)
            return 0.0;
        if(target.isDead())
            return 0.0;

        // Minimal: (pAtk / pDef) * someConstant
        double pAtk = attacker.getPAtk(target);
        double pDef = target.getPDef(attacker);
        if(pDef < 1) pDef = 1;

        // Shots
        if(ss)
            pAtk *= 2.0;

        double damage = (pAtk / pDef) * 70.0; 
        // Additional skill power if skill != null
        if(skill != null)
            damage += skill.getPower();
        // Random +- 10%
        damage *= 1.0 + (Rnd.get() * 0.2 - 0.1);

        return damage;
    }

    /**
     * Basic magic damage calculation for the MVP.
     */
    public static double calcMagicDam(Creature attacker, Creature target, Skill skill, boolean sps)
    {
        if(attacker == null || target == null)
            return 0.0;
        if(target.isDead())
            return 0.0;

        // Minimal: (mAtk / mDef) * base
        double mAtk = attacker.getMAtk(target, skill);
        double mDef = target.getMDef(target, skill);
        if(mDef < 1) mDef = 1;

        // Shots
        if(sps)
            mAtk *= 4.0; // Blessed spiritshots

        double power = skill != null ? skill.getPower() : 0.0;
        double damage = (mAtk / mDef) * 91.0 + power;
        // Some random factor
        damage *= 1.0 + (Rnd.get() * 0.2 - 0.1);

        return damage;
    }

    /**
     * Simplified chance-based effect success. 
     * Like a success chance from base + modifications.
     */
    public static boolean calcSkillSuccess(Creature attacker, Creature target, Skill skill, int baseChance)
    {
        if(attacker == null || target == null)
            return false;
        if(baseChance <= 0)
            return false;
        // Simple random check
        return Rnd.chance(baseChance);
    }

    /**
     * Minimally, we can choose an attack element 
     * or just none if not set. 
     */
    public static Element getAttackElement(Creature attacker, Creature target)
    {
        // For MVP, skip advanced logic. Return NONE.
        return Element.NONE;
    }

    /**
     * Minimally used to see if we break cast 
     * upon receiving damage. 
     */
    public static boolean calcCastBreak(Creature target, boolean crit)
    {
        if(target == null || !target.isCastingNow())
            return false;
        // Minimal: 10% chance plus some bump if crit
        return Rnd.chance(crit ? 30 : 10);
    }
}
// ============================================================================
// ====================== END MINIMIZED Formulas.java =========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\Formulas.java>

<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcInventory.java>
// ============================================================================
// ===================== MINIMIZED PcInventory.java ===========================
// ============================================================================
package l2ft.gameserver.model.items;

import l2ft.commons.threading.RunnableImpl;
import l2ft.gameserver.Config;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.InventoryUpdate;
import l2ft.gameserver.network.l2.s2c.SystemMessage;
import l2ft.gameserver.templates.item.EtcItemTemplate;
import l2ft.gameserver.templates.item.ItemTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized version of PcInventory for MVP:
 * - Retains basic item addition/removal logic
 * - Skips advanced shadow/temporal items, augmentation, 
 *   item-lister listeners, sorting, etc.
 */
public class PcInventory extends Inventory
{
    private static final Logger _log = LoggerFactory.getLogger(PcInventory.class);

    private final Player _owner;

    public PcInventory(Player owner)
    {
        super(owner.getObjectId());
        _owner = owner;
    }

    @Override
    public Player getActor()
    {
        return _owner;
    }

    @Override
    protected ItemLocation getBaseLocation()
    {
        return ItemLocation.INVENTORY;
    }

    @Override
    protected ItemLocation getEquipLocation()
    {
        return ItemLocation.PAPERDOLL;
    }

    /** Quick access to "adena" (ID 57). */
    public long getAdena()
    {
        ItemInstance adenaItem = getItemByItemId(ItemTemplate.ITEM_ID_ADENA);
        return adenaItem == null ? 0 : adenaItem.getCount();
    }

    public ItemInstance addAdena(long amount)
    {
        return addItem(ItemTemplate.ITEM_ID_ADENA, amount);
    }

    public boolean reduceAdena(long adena)
    {
        return destroyItemByItemId(ItemTemplate.ITEM_ID_ADENA, adena);
    }

    /**
     * Basic "validate items" logic to check if we can still equip them, 
     * removing if not. (omits advanced checks)
     */
    public void validateItems()
    {
        for(ItemInstance item : getPaperdollItems())
        {
            if(item == null)
                continue;
            // If an item is not allowed, unEquip it.
            if(!ItemFunctions.checkIfCanEquip(getActor(), item))
            {
                unEquipItem(item);
                getActor().sendDisarmMessage(item);
            }
        }
    }

    /**
     * Overridden so that the player's overloaded status is updated 
     * whenever weight changes.
     */
    @Override
    protected void onRefreshWeight()
    {
        getActor().refreshOverloaded();
    }

    /**
     * Minimal store() logic (in real code, DB updates happen here).
     */
    @Override
    public void store()
    {
        // No-op for MVP
    }

    /**
     * Minimal restore() logic (in real code, DB loading happens here).
     */
    @Override
    public void restore()
    {
        // No-op for MVP
    }

    /**
     * Basic capacity for the MVP - skipping expansions etc.
     */
    public int getMaxSlots()
    {
        return 80; 
    }

    @Override
    protected void sendAddItem(ItemInstance item)
    {
        getActor().sendPacket(new InventoryUpdate().addNewItem(item));
    }

    @Override
    protected void sendModifyItem(ItemInstance item)
    {
        getActor().sendPacket(new InventoryUpdate().addModifiedItem(item));
    }

    @Override
    protected void sendRemoveItem(ItemInstance item)
    {
        getActor().sendPacket(new InventoryUpdate().addRemovedItem(item));
    }
}
// ============================================================================
// =================== END MINIMIZED PcInventory.java =========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcInventory.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcWarehouse.java>
package l2ft.gameserver.model.items;

import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.items.ItemInstance.ItemLocation;

public class PcWarehouse extends Warehouse
{
	public PcWarehouse(Player owner)
	{
		super(owner.getObjectId());
	}

	public PcWarehouse(int ownerId)
	{
		super(ownerId);
	}

	@Override
	public ItemLocation getItemLocation()
	{
		return ItemLocation.WAREHOUSE;
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcWarehouse.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcFreight.java>
package l2ft.gameserver.model.items;

import l2ft.gameserver.model.Player;

/**
 * @author VISTALL
 * @date 20:20/16.05.2011
 */
public class PcFreight extends Warehouse
{
	public PcFreight(Player player)
	{
		super(player.getObjectId());
	}

	public PcFreight(int objectId)
	{
		super(objectId);
	}

	@Override
	public ItemInstance.ItemLocation getItemLocation()
	{
		return ItemInstance.ItemLocation.FREIGHT;
	}
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\items\PcFreight.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\actor\instances\player\ShortCutList.java>
package l2ft.gameserver.model.actor.instances.player;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import l2ft.commons.dbutils.DbUtils;
import l2ft.gameserver.cache.Msg;
import l2ft.gameserver.database.DatabaseFactory;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.network.l2.s2c.ExAutoSoulShot;
import l2ft.gameserver.network.l2.s2c.ShortCutInit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ShortCutList
{
	private static final Logger _log = LoggerFactory.getLogger(ShortCutList.class);

	private final Player player;
	private Map<Integer, ShortCut> _shortCuts = new ConcurrentHashMap<Integer, ShortCut>();

	public ShortCutList(Player owner)
	{
		player = owner;
	}

	public Collection<ShortCut> getAllShortCuts()
	{
		return _shortCuts.values();
	}

	public void validate()
	{
		// Проверка ярлыков
		for(ShortCut sc : _shortCuts.values())
			// Удаляем ярлыки на предметы, которых нету в инвентаре
			if(sc.getType() == ShortCut.TYPE_ITEM)
				if(player.getInventory().getItemByObjectId(sc.getId()) == null)
					deleteShortCut(sc.getSlot(), sc.getPage());
	}

	public ShortCut getShortCut(int slot, int page)
	{
		ShortCut sc = _shortCuts.get(slot + page * 12);
		// verify shortcut
		if(sc != null && sc.getType() == ShortCut.TYPE_ITEM)
			if(player.getInventory().getItemByObjectId(sc.getId()) == null)
			{
				player.sendPacket(Msg.THERE_ARE_NO_MORE_ITEMS_IN_THE_SHORTCUT);
				deleteShortCut(sc.getSlot(), sc.getPage());
				sc = null;
			}
		return sc;
	}

	public void registerShortCut(ShortCut shortcut)
	{
		ShortCut oldShortCut = _shortCuts.put(shortcut.getSlot() + 12 * shortcut.getPage(), shortcut);
		registerShortCutInDb(shortcut, oldShortCut);
	}

	private synchronized void registerShortCutInDb(ShortCut shortcut, ShortCut oldShortCut)
	{
		if(oldShortCut != null)
			deleteShortCutFromDb(oldShortCut);
		
		int[] classes = getClasses();

		Connection con = null;
		PreparedStatement statement = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("REPLACE INTO character_shortcuts SET object_id=?,slot=?,page=?,type=?,shortcut_id=?,level=?,character_type=?,class_index=?,second_class_index=?");
			statement.setInt(1, player.getObjectId());
			statement.setInt(2, shortcut.getSlot());
			statement.setInt(3, shortcut.getPage());
			statement.setInt(4, shortcut.getType());
			statement.setInt(5, shortcut.getId());
			statement.setInt(6, shortcut.getLevel());
			statement.setInt(7, shortcut.getCharacterType());
			statement.setInt(8, classes[0]);
			statement.setInt(9, classes[1]);
			statement.execute();
		}
		catch(Exception e)
		{
			_log.error("could not store shortcuts, classes 0:"+classes[0]+" classes 1:"+classes[1], e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement);
		}
	}
	
	public int[] getClasses()
	{
		int[] classes = {player.getFirstClassId(), player.getSecondaryClassId()};
		Arrays.sort(classes);
		return classes;
	}

	/**
	 * @param shortcut
	 */
	private void deleteShortCutFromDb(ShortCut shortcut)
	{
		Connection con = null;
		PreparedStatement statement = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("DELETE FROM character_shortcuts WHERE object_id=? AND slot=? AND page=? AND class_index=? AND second_class_index=?");
			statement.setInt(1, player.getObjectId());
			statement.setInt(2, shortcut.getSlot());
			statement.setInt(3, shortcut.getPage());
			int[] classes = getClasses();
			statement.setInt(4, classes[0]);
			statement.setInt(5, classes[1]);
			statement.execute();
		}
		catch(Exception e)
		{
			_log.error("could not delete shortcuts:", e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement);
		}
	}

	/**
	 * Удаляет ярлык с пользовательской панели по номеру страницы и слота.
	 * @param slot
	 * @param page
	 */
	public void deleteShortCut(int slot, int page)
	{
		ShortCut old = _shortCuts.remove(slot + page * 12);
		if(old == null)
			return;
		deleteShortCutFromDb(old);
		// При удалении с панели скила, на оффе шлется полный инит ярлыков
		// Обработка удаления предметных ярлыков - клиент сайд.
		if(old.getType() == ShortCut.TYPE_SKILL)
		{
			player.sendPacket(new ShortCutInit(player));
			for(int shotId : player.getAutoSoulShot())
				player.sendPacket(new ExAutoSoulShot(shotId, true));
		}
	}

	/**
	 * Удаляет ярлык предмета с пользовательской панели.
	 * @param objectId
	 */
	public void deleteShortCutByObjectId(int objectId)
	{
		for(ShortCut shortcut : _shortCuts.values())
			if(shortcut != null && shortcut.getType() == ShortCut.TYPE_ITEM && shortcut.getId() == objectId)
				deleteShortCut(shortcut.getSlot(), shortcut.getPage());
	}

	/**
	 * Удаляет ярлык скила с пользовательской панели.
	 * @param skillId
	 */
	public void deleteShortCutBySkillId(int skillId)
	{
		for(ShortCut shortcut : _shortCuts.values())
			if(shortcut != null && shortcut.getType() == ShortCut.TYPE_SKILL && shortcut.getId() == skillId)
				deleteShortCut(shortcut.getSlot(), shortcut.getPage());
	}

	public void restore()
	{
		_shortCuts.clear();
		
		Connection con = null;
		PreparedStatement statement = null;
		ResultSet rset = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("SELECT character_type, slot, page, type, shortcut_id, level FROM character_shortcuts WHERE object_id=? AND class_index=? AND second_class_index=?");
			statement.setInt(1, player.getObjectId());
			int[] classes = getClasses();
			statement.setInt(2, classes[0]);
			statement.setInt(3, classes[1]);
			rset = statement.executeQuery();
			while(rset.next())
			{
				int slot = rset.getInt("slot");
				int page = rset.getInt("page");
				int type = rset.getInt("type");
				int id = rset.getInt("shortcut_id");
				int level = rset.getInt("level");
				int character_type = rset.getInt("character_type");

				_shortCuts.put(slot + page * 12, new ShortCut(slot, page, type, id, level, character_type));
			}
		}
		catch(Exception e)
		{
			_log.error("could not store shortcuts:", e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement, rset);
		}
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\actor\instances\player\ShortCutList.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\actor\instances\player\MacroList.java>
package l2ft.gameserver.model.actor.instances.player;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import l2ft.commons.dbutils.DbUtils;
import l2ft.gameserver.database.DatabaseFactory;
import l2ft.gameserver.model.actor.instances.player.Macro.L2MacroCmd;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.network.l2.s2c.SendMacroList;
import l2ft.gameserver.utils.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MacroList
{
	private static final Logger _log = LoggerFactory.getLogger(MacroList.class);

	private final Player player;
	private final Map<Integer, Macro> _macroses = new HashMap<Integer, Macro>();
	private int _revision;
	private int _macroId;

	public MacroList(Player player)
	{
		this.player = player;
		_revision = 1;
		_macroId = 1000;
	}

	public int getRevision()
	{
		return _revision;
	}

	public Macro[] getAllMacroses()
	{
		return _macroses.values().toArray(new Macro[_macroses.size()]);
	}

	public Macro getMacro(int id)
	{
		return _macroses.get(id - 1);
	}

	public void registerMacro(Macro macro)
	{
		if(macro.id == 0)
		{
			macro.id = _macroId++;
			while(_macroses.get(macro.id) != null)
				macro.id = _macroId++;
			_macroses.put(macro.id, macro);
			registerMacroInDb(macro);
		}
		else
		{
			Macro old = _macroses.put(macro.id, macro);
			if(old != null)
				deleteMacroFromDb(old);
			registerMacroInDb(macro);
		}
		sendUpdate();
	}

	public void deleteMacro(int id)
	{
		Macro toRemove = _macroses.get(id);
		if(toRemove != null)
			deleteMacroFromDb(toRemove);
		_macroses.remove(id);
		//		L2ShortCut[] allShortCuts = _owner.getAllShortCuts();
		//		for(L2ShortCut sc : allShortCuts) {
		//			if(sc.getId() == id && sc.getType() == L2ShortCut.TYPE_MACRO)
		//				_owner.sendPacket(new ShortCutRegister(sc.getSlot(), 0, 0, 0, sc.getPage()));
		//		}
		sendUpdate();
	}

	public void sendUpdate()
	{
		_revision++;
		Macro[] all = getAllMacroses();
		if(all.length == 0)
			player.sendPacket(new SendMacroList(_revision, all.length, null));
		else
			for(Macro m : all)
				player.sendPacket(new SendMacroList(_revision, all.length, m));
	}

	private void registerMacroInDb(Macro macro)
	{
		Connection con = null;
		PreparedStatement statement = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("REPLACE INTO character_macroses (char_obj_id,id,icon,name,descr,acronym,commands) values(?,?,?,?,?,?,?)");
			statement.setInt(1, player.getObjectId());
			statement.setInt(2, macro.id);
			statement.setInt(3, macro.icon);
			statement.setString(4, macro.name);
			statement.setString(5, macro.descr);
			statement.setString(6, macro.acronym);
			StringBuilder sb = new StringBuilder();
			for(L2MacroCmd cmd : macro.commands)
			{
				sb.append(cmd.type).append(',');
				sb.append(cmd.d1).append(',');
				sb.append(cmd.d2);
				if(cmd.cmd != null && cmd.cmd.length() > 0)
					sb.append(',').append(cmd.cmd);
				sb.append(';');
			}
			statement.setString(7, sb.toString());
			statement.execute();
		}
		catch(Exception e)
		{
			_log.error("could not store macro: " + macro.toString(), e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement);
		}
	}

	/**
	 * @param shortcut
	 */
	private void deleteMacroFromDb(Macro macro)
	{
		Connection con = null;
		PreparedStatement statement = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("DELETE FROM character_macroses WHERE char_obj_id=? AND id=?");
			statement.setInt(1, player.getObjectId());
			statement.setInt(2, macro.id);
			statement.execute();
		}
		catch(Exception e)
		{
			_log.error("could not delete macro:", e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement);
		}
	}

	public void restore()
	{
		_macroses.clear();
		Connection con = null;
		PreparedStatement statement = null;
		ResultSet rset = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("SELECT char_obj_id, id, icon, name, descr, acronym, commands FROM character_macroses WHERE char_obj_id=?");
			statement.setInt(1, player.getObjectId());
			rset = statement.executeQuery();
			while(rset.next())
			{
				int id = rset.getInt("id");
				int icon = rset.getInt("icon");
				String name = Strings.stripSlashes(rset.getString("name"));
				String descr = Strings.stripSlashes(rset.getString("descr"));
				String acronym = Strings.stripSlashes(rset.getString("acronym"));
				List<L2MacroCmd> commands = new ArrayList<L2MacroCmd>();
				StringTokenizer st1 = new StringTokenizer(rset.getString("commands"), ";");
				while(st1.hasMoreTokens())
				{
					StringTokenizer st = new StringTokenizer(st1.nextToken(), ",");
					int type = Integer.parseInt(st.nextToken());
					int d1 = Integer.parseInt(st.nextToken());
					int d2 = Integer.parseInt(st.nextToken());
					String cmd = "";
					if(st.hasMoreTokens())
						cmd = st.nextToken();
					L2MacroCmd mcmd = new L2MacroCmd(commands.size(), type, d1, d2, cmd);
					commands.add(mcmd);
				}

				Macro m = new Macro(id, icon, name, descr, acronym, commands.toArray(new L2MacroCmd[commands.size()]));
				_macroses.put(m.id, m);
			}
		}
		catch(Exception e)
		{
			_log.error("could not restore shortcuts:", e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement, rset);
		}
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\actor\instances\player\MacroList.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CharacterAI.java>
package l2ft.gameserver.ai;

import l2ft.commons.threading.RunnableImpl;
import l2ft.gameserver.ThreadPoolManager;
import l2ft.gameserver.ai.PlayableAI.nextAction;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.network.l2.s2c.Die;
import l2ft.gameserver.utils.Location;

public class CharacterAI extends AbstractAI
{
	public CharacterAI(Creature actor)
	{
		super(actor);
	}

	@Override
	protected void onIntentionIdle()
	{
		clientStopMoving();
		changeIntention(CtrlIntention.AI_INTENTION_IDLE, null, null);
	}

	@Override
	protected void onIntentionActive()
	{
		clientStopMoving();
		changeIntention(CtrlIntention.AI_INTENTION_ACTIVE, null, null);
		onEvtThink();
	}

	@Override
	protected void onIntentionAttack(Creature target)
	{
		setAttackTarget(target);
		clientStopMoving();
		changeIntention(CtrlIntention.AI_INTENTION_ATTACK, target, null);
		onEvtThink();
	}

	@Override
	protected void onIntentionCast(Skill skill, Creature target)
	{
		setAttackTarget(target);
		changeIntention(CtrlIntention.AI_INTENTION_CAST, skill, target);
		onEvtThink();
	}

	@Override
	protected void onIntentionFollow(Creature target, Integer offset)
	{
		changeIntention(CtrlIntention.AI_INTENTION_FOLLOW, target, offset);
		onEvtThink();
	}

	@Override
	protected void onIntentionInteract(GameObject object)
	{}

	@Override
	protected void onIntentionPickUp(GameObject item)
	{}

	@Override
	protected void onIntentionRest()
	{}

	@Override
	protected void onIntentionCoupleAction(Player player, Integer socialId)
	{}

	@Override
	protected void onEvtArrivedBlocked(Location blocked_at_pos)
	{
		Creature actor = getActor();
		if(actor.isPlayer())
		{
			// Приводит к застреванию в стенах:
			//if(actor.isInRange(blocked_at_pos, 1000))
			//	actor.setLoc(blocked_at_pos, true);
			// Этот способ надежнее:
			Location loc = ((Player) actor).getLastServerPosition();
			if(loc != null)
				actor.setLoc(loc, true);
			actor.stopMove();
		}
		onEvtThink();
	}

	@Override
	protected void onEvtForgetObject(GameObject object)
	{
		if(object == null)
			return;

		Creature actor = getActor();

		if(actor.isAttackingNow() && getAttackTarget() == object)
			actor.abortAttack(true, true);

		if(actor.isCastingNow() && getAttackTarget() == object)
			actor.abortCast(true, true);

		if(getAttackTarget() == object)
			setAttackTarget(null);

		if(actor.getTargetId() == object.getObjectId())
			actor.setTarget(null);

		if(actor.getFollowTarget() == object)
			actor.setFollowTarget(null);

		if(actor.getPet() != null)
			actor.getPet().getAI().notifyEvent(CtrlEvent.EVT_FORGET_OBJECT, object);
	}

	@Override
	protected void onEvtDead(Creature killer)
	{
		Creature actor = getActor();

		actor.abortAttack(true, true);
		actor.abortCast(true, true);
		actor.stopMove();
		actor.broadcastPacket(new Die(actor));

		setIntention(CtrlIntention.AI_INTENTION_IDLE);
	}

	@Override
	protected void onEvtFakeDeath()
	{
		clientStopMoving();
		setIntention(CtrlIntention.AI_INTENTION_IDLE);
	}

	@Override
	protected void onEvtAttacked(Creature attacker, int damage)
	{

	}

	@Override
	protected void onEvtClanAttacked(Creature attacked_member, Creature attacker, int damage)
	{}

	public void Attack(GameObject target, boolean forceUse, boolean dontMove)
	{
		setIntention(CtrlIntention.AI_INTENTION_ATTACK, target);
	}

	public void Cast(Skill skill, Creature target)
	{
		Cast(skill, target, false, false);
	}

	public void Cast(Skill skill, Creature target, boolean forceUse, boolean dontMove)
	{
		setIntention(CtrlIntention.AI_INTENTION_ATTACK, target);
	}

	@Override
	protected void onEvtThink()
	{}

	@Override
	protected void onEvtAggression(Creature target, int aggro)
	{}

	@Override
	protected void onEvtFinishCasting()
	{}

	@Override
	protected void onEvtReadyToAct()
	{}

	@Override
	protected void onEvtArrived()
	{}

	@Override
	protected void onEvtArrivedTarget()
	{}

	@Override
	protected void onEvtSeeSpell(Skill skill, Creature caster)
	{}

	@Override
	protected void onEvtSpawn()
	{}

	@Override
	public void onEvtDeSpawn()
	{}

	public void stopAITask()
	{}

	public void startAITask()
	{}

	public void setNextAction(nextAction action, Object arg0, Object arg1, boolean arg2, boolean arg3)
	{}

	public void clearNextAction()
	{}

	public boolean isActive()
	{
		return true;
	}

	@Override
	protected void onEvtTimer(int timerId, Object arg1, Object arg2)
	{}

	public void addTimer(int timerId, long delay)
	{
		addTimer(timerId, null, null, delay);
	}

	public void addTimer(int timerId, Object arg1, long delay)
	{
		addTimer(timerId, arg1, null, delay);
	}

	public void addTimer(int timerId, Object arg1, Object arg2, long delay)
	{
		ThreadPoolManager.getInstance().schedule(new Timer(timerId, arg1, arg2), delay);
	}

	protected class Timer extends RunnableImpl
	{
		private int _timerId;
		private Object _arg1;
		private Object _arg2;

		public Timer(int timerId, Object arg1, Object arg2)
		{
			_timerId = timerId;
			_arg1 = arg1;
			_arg2 = arg2;
		}

		public void runImpl()
		{
			notifyEvent(CtrlEvent.EVT_TIMER, _timerId, _arg1, _arg2);
		}
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CharacterAI.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\PlayerAI.java>
package l2ft.gameserver.ai;

import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_ACTIVE;

import l2ft.gameserver.Config;
import l2ft.gameserver.geodata.GeoEngine;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.model.Skill.SkillType;
import l2ft.gameserver.model.items.attachment.FlagItemAttachment;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.ActionFail;
import l2ft.gameserver.network.l2.s2c.ExRotation;
import l2ft.gameserver.network.l2.s2c.SocialAction;

public class PlayerAI extends PlayableAI
{
	public PlayerAI(Player actor)
	{
		super(actor);
	}

	@Override
	protected void onIntentionRest()
	{
		changeIntention(CtrlIntention.AI_INTENTION_REST, null, null);
		setAttackTarget(null);
		clientStopMoving();
	}

	@Override
	protected void onIntentionActive()
	{
		clearNextAction();
		changeIntention(CtrlIntention.AI_INTENTION_ACTIVE, null, null);
	}

	@Override
	public void onIntentionInteract(GameObject object)
	{
		Player actor = getActor();

		if(actor.getSittingTask())
		{
			setNextAction(nextAction.INTERACT, object, null, false, false);
			return;
		}
		else if(actor.isSitting())
		{
			actor.sendPacket(SystemMsg.YOU_CANNOT_MOVE_WHILE_SITTING);
			clientActionFailed();
			return;
		}
		super.onIntentionInteract(object);
	}

	@Override
	public void onIntentionPickUp(GameObject object)
	{
		Player actor = getActor();

		if(actor.getSittingTask())
		{
			setNextAction(nextAction.PICKUP, object, null, false, false);
			return;
		}
		else if(actor.isSitting())
		{
			actor.sendPacket(SystemMsg.YOU_CANNOT_MOVE_WHILE_SITTING);
			clientActionFailed();
			return;
		}
		super.onIntentionPickUp(object);
	}

	@Override
	protected void thinkAttack(boolean checkRange)
	{
		Player actor = getActor();

		if(actor.isInFlyingTransform())
		{
			setIntention(CtrlIntention.AI_INTENTION_ACTIVE);
			return;
		}

		FlagItemAttachment attachment = actor.getActiveWeaponFlagAttachment();
		if(attachment != null && !attachment.canAttack(actor))
		{
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
			return;
		}

		if(actor.isFrozen())
		{
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendPacket(SystemMsg.YOU_CANNOT_MOVE_WHILE_FROZEN, ActionFail.STATIC);
			return;
		}

		super.thinkAttack(checkRange);
	}

	@Override
	protected void thinkCast(boolean checkRange)
	{
		Player actor = getActor();

		FlagItemAttachment attachment = actor.getActiveWeaponFlagAttachment();
		if(attachment != null && !attachment.canCast(actor, _skill))
		{
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
			return;
		}

		if(actor.isFrozen())
		{
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendPacket(SystemMsg.YOU_CANNOT_MOVE_WHILE_FROZEN, ActionFail.STATIC);
			return;
		}

		super.thinkCast(checkRange);
	}

	@Override
	protected void thinkCoupleAction(Player target, Integer socialId, boolean cancel)
	{
		Player actor = getActor();
		if(target == null || !target.isOnline())
		{
			actor.sendPacket(SystemMsg.THE_COUPLE_ACTION_WAS_CANCELLED);
			return;
		}

		if(cancel || !actor.isInRange(target, 50) || actor.isInRange(target, 20) || actor.getReflection() != target.getReflection() || !GeoEngine.canSeeTarget(actor, target, false))
		{
			target.sendPacket(SystemMsg.THE_COUPLE_ACTION_WAS_CANCELLED);
			actor.sendPacket(SystemMsg.THE_COUPLE_ACTION_WAS_CANCELLED);
			return;
		}
		if(_forceUse) // служит только для флага что б активировать у другого игрока социалку
			target.getAI().setIntention(CtrlIntention.AI_INTENTION_COUPLE_ACTION, actor, socialId);
		//
		int heading = actor.calcHeading(target.getX(), target.getY());
		actor.setHeading(heading);
		actor.broadcastPacket(new ExRotation(actor.getObjectId(), heading));
		//
		actor.broadcastPacket(new SocialAction(actor.getObjectId(), socialId));
	}

	@Override
	public void Attack(GameObject target, boolean forceUse, boolean dontMove)
	{
		Player actor = getActor();

		if(actor.isInFlyingTransform())
		{
			actor.sendActionFailed();
			return;
		}

		if(System.currentTimeMillis() - actor.getLastAttackPacket() < Config.ATTACK_PACKET_DELAY)
		{
			actor.sendActionFailed();
			return;
		}

		actor.setLastAttackPacket();

		if(actor.getSittingTask())
		{
			setNextAction(nextAction.ATTACK, target, null, forceUse, false);
			return;
		}
		else if(actor.isSitting())
		{
			actor.sendPacket(SystemMsg.YOU_CANNOT_MOVE_WHILE_SITTING);
			clientActionFailed();
			return;
		}

		super.Attack(target, forceUse, dontMove);
	}

	@Override
	public void Cast(Skill skill, Creature target, boolean forceUse, boolean dontMove)
	{
		Player actor = getActor();

		if(!skill.altUse() && !skill.isToggle() && !(skill.getSkillType() == SkillType.CRAFT && Config.ALLOW_TALK_WHILE_SITTING))
			// Если в этот момент встаем, то использовать скилл когда встанем
			if(actor.getSittingTask())
			{
				setNextAction(nextAction.CAST, skill, target, forceUse, dontMove);
				clientActionFailed();
				return;
			}
			else if(skill.getSkillType() == SkillType.SUMMON && actor.getPrivateStoreType() != Player.STORE_PRIVATE_NONE)
			{
				actor.sendPacket(SystemMsg.YOU_CANNOT_SUMMON_DURING_A_TRADE_OR_WHILE_USING_A_PRIVATE_STORE);
				clientActionFailed();
				return;
			}
		// если сидим - скиллы нельзя использовать
			else if(actor.isSitting())
			{
				if(skill.getSkillType() == SkillType.TRANSFORMATION)
					actor.sendPacket(SystemMsg.YOU_CANNOT_TRANSFORM_WHILE_SITTING);
				else
					actor.sendPacket(SystemMsg.YOU_CANNOT_MOVE_WHILE_SITTING);

				clientActionFailed();
				return;
			}

		super.Cast(skill, target, forceUse, dontMove);
	}

	@Override
	public Player getActor()
	{
		return (Player) super.getActor();
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\PlayerAI.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CtrlIntention.java>
package l2ft.gameserver.ai;

/** Enumaration of generic intentions of an NPC/PC, an intention may require
 * several steps to be completed */

public enum CtrlIntention
{
	/** Do nothing, disconnect AI of NPC if no players around */
	AI_INTENTION_IDLE,
	/** Alerted state without goal : scan attackable targets, random walk, etc */
	AI_INTENTION_ACTIVE,
	/** Rest (sit untill attacked) */
	AI_INTENTION_REST,
	/** Attack target (cast combat magic, go to target, combat), may be ignored,
	 * if target is locked on another character or a peacefull zone and so on */
	AI_INTENTION_ATTACK,
	/** Cast a spell, depending on the spell - may start or stop attacking */
	AI_INTENTION_CAST,
	/** PickUp and item, (got to item, pickup it, become idle */
	AI_INTENTION_PICK_UP,
	/** Move to target, then interact */
	AI_INTENTION_INTERACT,
	/** Follow to target */
	AI_INTENTION_FOLLOW,
	/** Couple Action(dance, etc) */
	AI_INTENTION_COUPLE_ACTION
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CtrlIntention.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CtrlEvent.java>
package l2ft.gameserver.ai;

/**
 * This class contains an enum of each possibles evenements that can happen on an AI character.
 */

public enum CtrlEvent
{
	/** Something has changed, usually a previous step has being completed
	 * or maybe was completed, the AI must thing on next action
	 */
	EVT_THINK,
	/** The actor was attacked. This event comes each time a physical or magical
	 * attack was done on the actor. NPC may start attack in responce, or ignore
	 * this event if they already attack someone, or change target and so on.
	 */
	EVT_ATTACKED,
	EVT_CLAN_ATTACKED,
	/** Increase/decrease aggression towards a target, or reduce global aggression if target is null */
	EVT_AGGRESSION,
	/** An event that previous action was completed. The action may be an attempt
	 * to physically/magically hit an enemy, or an action that discarded
	 * attack attempt has finished. */
	EVT_READY_TO_ACT,
	/** The actor arrived to assigned location, or it's a time to modify
	 * movement destination (follow, interact, random move and others intentions). */
	EVT_ARRIVED,
	EVT_ARRIVED_TARGET,
	/** The actor cannot move anymore. */
	EVT_ARRIVED_BLOCKED,
	/** Forgets an object (if it's used as attack target, follow target and so on */
	EVT_FORGET_OBJECT,
	/** The character is dead */
	EVT_DEAD,
	/** The character looks like dead */
	EVT_FAKE_DEATH,
	/** The character finish casting **/
	EVT_FINISH_CASTING,
	EVT_SEE_SPELL,
	EVT_SPAWN,
	EVT_DESPAWN,
	EVT_TIMER,
	EVT_TELEPORTED
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\CtrlEvent.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\utils\Log.java>
package l2ft.gameserver.utils;


import l2ft.commons.text.PrintfFormat;
import l2ft.gameserver.Config;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.items.ItemInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Log
{
	public static final PrintfFormat LOG_BOSS_KILLED = new PrintfFormat("%s: %s[%d] killed by %s at Loc(%d %d %d) in %s");
	public static final PrintfFormat LOG_BOSS_RESPAWN = new PrintfFormat("%s: %s[%d] scheduled for respawn in %s at %s");

	private static final Logger _log = LoggerFactory.getLogger(Log.class);

	private static final Logger _logChat = LoggerFactory.getLogger("chat");
	private static final Logger _logGm = LoggerFactory.getLogger("gmactions");
	private static final Logger _logItems = LoggerFactory.getLogger("item");
	private static final Logger _logGame = LoggerFactory.getLogger("game");
	private static final Logger _logDebug = LoggerFactory.getLogger("debug");

	public static final String Create = "Create";
	public static final String Delete = "Delete";
	public static final String Drop = "Drop";
	public static final String PvPDrop = "PvPDrop";
	public static final String Crystalize = "Crystalize";
	public static final String EnchantFail = "EnchantFail";
	public static final String Pickup = "Pickup";
	public static final String PartyPickup = "PartyPickup";
	public static final String PrivateStoreBuy = "PrivateStoreBuy";
	public static final String PrivateStoreSell = "PrivateStoreSell";
	public static final String TradeBuy = "TradeBuy";
	public static final String TradeSell = "TradeSell";
	public static final String PostRecieve = "PostRecieve";
	public static final String PostSend = "PostSend";
	public static final String PostCancel = "PostCancel";
	public static final String PostExpire = "PostExpire";
	public static final String RefundSell = "RefundSell";
	public static final String RefundReturn = "RefundReturn";
	public static final String WarehouseDeposit = "WarehouseDeposit";
	public static final String WarehouseWithdraw = "WarehouseWithdraw";
	public static final String FreightWithdraw = "FreightWithdraw";
	public static final String FreightDeposit = "FreightDeposit";
	public static final String ClanWarehouseDeposit = "ClanWarehouseDeposit";
	public static final String ClanWarehouseWithdraw = "ClanWarehouseWithdraw";

	public static void add(PrintfFormat fmt, Object[] o, String cat)
	{
		add(fmt.sprintf(o), cat);
	}

	public static void add(String fmt, Object[] o, String cat)
	{
		add(new PrintfFormat(fmt).sprintf(o), cat);
	}

	public static void add(String text, String cat, Player player)
	{
		StringBuilder output = new StringBuilder();

		output.append(cat);
		if(player != null)
		{
			output.append(' ');
			output.append(player);
		}
		output.append(' ');
		output.append(text);

		_logGame.info(output.toString());
	}

	public static void add(String text, String cat)
	{
		add(text, cat, null);
	}

	public static void debug(String text)
	{
		_logDebug.debug(text);
	}

	public static void debug(String text, Throwable t)
	{
		_logDebug.debug(text, t);
	}

	public static void LogChat(String type, String player, String target, String text)
	{
		if(!Config.LOG_CHAT)
			return;

		StringBuilder output = new StringBuilder();
		output.append(type);
		output.append(' ');
		output.append('[');
		output.append(player);
		if(target != null)
		{
			output.append(" -> ");
			output.append(target);
		}
		output.append(']');
		output.append(' ');
		output.append(text);

		_logChat.info(output.toString());
	}

	public static void LogCommand(Player player, GameObject target, String command, boolean success)
	{
		//if(!Config.LOG_GM)
		//	return;

		StringBuilder output = new StringBuilder();

		if(success)
			output.append("SUCCESS");
		else
			output.append("FAIL   ");

		output.append(' ');
		output.append(player);
		if(target != null)
		{
			output.append(" -> ");
			output.append(target);
		}
		output.append(' ');
		output.append(command);

		_logGm.info(output.toString());
	}

	public static void LogItem(Creature activeChar, String process, ItemInstance item)
	{
		LogItem(activeChar, process, item, item.getCount());
	}

	public static void LogItem(Creature activeChar, String process, ItemInstance item, long count)
	{
		//if(!Config.LOG_ITEM)
		//	return;

		StringBuilder output = new StringBuilder();
		output.append(process);
		output.append(' ');
		output.append(item);
		output.append(' ');
		output.append(activeChar);
		output.append(' ');
		output.append(count);

		_logItems.info(output.toString());
	}

	public static void LogPetition(Player fromChar, Integer Petition_type, String Petition_text)
	{
		//TODO: implement
	}

	public static void LogAudit(Player player, String type, String msg)
	{
		//TODO: implement
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\utils\Log.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\utils\ItemFunctions.java>
// ============================================================================
// ====================== MINIMIZED ItemFunctions.java ========================
// ============================================================================
package l2ft.gameserver.utils;

import l2ft.gameserver.model.Playable;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.items.ItemInstance;
import l2ft.gameserver.templates.item.ItemTemplate;

/**
 * Minimized version of ItemFunctions for MVP:
 * - Contains a few static checks used by Player.java (pickup logic, etc.).
 * - Skips advanced enchant, attribute, augmentation, etc.
 */
public final class ItemFunctions
{
    private ItemFunctions() { }

    /**
     * Check if a playable can pick up a specific item instance. 
     * For MVP, we skip advanced "drop time" or "clan item" logic,
     * we simply require the item to be visible.
     */
    public static boolean checkIfCanPickup(Playable playable, ItemInstance item)
    {
        // The MVP logic in Player.doPickupItem(...) references this.
        // For simplicity, let's say any visible item can be picked up if it's not already gone.
        return item.isVisible();
    }

    /**
     * Check if an item can be added to the player's inventory 
     * (weight, capacity, etc.).
     */
    public static boolean canAddItem(Player player, ItemInstance item)
    {
        if(!player.getInventory().validateWeight(item))
        {
            player.sendMessage("You are overweight.");
            return false;
        }
        if(!player.getInventory().validateCapacity(item))
        {
            player.sendMessage("Your inventory is full.");
            return false;
        }
        return true;
    }

    /**
     * For MVP: a stub creation of an item instance.
     */
    public static ItemInstance createItem(int itemId)
    {
        ItemInstance item = new ItemInstance(0, itemId);
        item.setLocation(ItemInstance.ItemLocation.VOID);
        item.setCount(1L);
        return item;
    }

    /**
     * For MVP: we also define a trivial "checkIfCanEquip" used by validateItems(),
     * but skip advanced checks (clan/hero items, etc.).
     */
    public static boolean checkIfCanEquip(Player player, ItemInstance item)
    {
        // Minimal: we allow equipping everything in MVP
        // unless item is over some complexity.
        // So always true for the MVP.
        return true;
    }
}
// ============================================================================
// ==================== END MINIMIZED ItemFunctions.java ======================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\utils\ItemFunctions.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\templates\PlayerTemplate.java>
package l2ft.gameserver.templates;

import java.util.ArrayList;
import java.util.List;

import l2ft.gameserver.data.xml.holder.ItemHolder;
import l2ft.gameserver.model.base.ClassId;
import l2ft.gameserver.model.base.Race;
import l2ft.gameserver.templates.item.ItemTemplate;
import l2ft.gameserver.utils.Location;


public class PlayerTemplate extends CharTemplate
{
	/** The Class<?> object of the L2Player */
	public final ClassId classId;

	public final Race race;
	public final String className;

	public final Location spawnLoc = new Location();

	public final boolean isMale;

	public final int classBaseLevel;
	public final double lvlHpAdd;
	public final double lvlHpMod;
	public final double lvlCpAdd;
	public final double lvlCpMod;
	public final double lvlMpAdd;
	public final double lvlMpMod;

	private List<ItemTemplate> _items = new ArrayList<ItemTemplate>();

	public PlayerTemplate(StatsSet set)
	{
		super(set);
		classId = ClassId.VALUES[set.getInteger("classId")];
		race = Race.values()[set.getInteger("raceId")];
		className = set.getString("className");

		spawnLoc.set(new Location(-117345, 87178, -12695));

		isMale = set.getBool("isMale", true);

		classBaseLevel = set.getInteger("classBaseLevel");
		lvlHpAdd = set.getDouble("lvlHpAdd");
		lvlHpMod = set.getDouble("lvlHpMod");
		lvlCpAdd = set.getDouble("lvlCpAdd");
		lvlCpMod = set.getDouble("lvlCpMod");
		lvlMpAdd = set.getDouble("lvlMpAdd");
		lvlMpMod = set.getDouble("lvlMpMod");
	}

	/**
	 * add starter equipment
	 * @param i
	 */
	public void addItem(int itemId)
	{
		ItemTemplate item = ItemHolder.getInstance().getTemplate(itemId);
		if(item != null)
			_items.add(item);
	}

	/**
	 *
	 * @return itemIds of all the starter equipment
	 */
	public ItemTemplate[] getItems()
	{
		return _items.toArray(new ItemTemplate[_items.size()]);
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\templates\PlayerTemplate.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\SystemMessage2.java>
package l2ft.gameserver.network.l2.s2c;

import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.items.ItemInstance;
import l2ft.gameserver.network.l2.components.SystemMsg;

/**
 * @author VISTALL
 * @date 14:45/08.03.2011
 */
public class SystemMessage2 extends SysMsgContainer<SystemMessage2>
{
	public SystemMessage2(SystemMsg message)
	{
		super(message);
	}

	public SystemMessage2()
	{
		super("");
	}

	public static SystemMessage2 obtainItems(int itemId, long count, int enchantLevel)
	{
		if(itemId == 57)
			return new SystemMessage2(SystemMsg.YOU_HAVE_EARNED_S1_ADENA).addLong(count);
		if(count > 1)
			return new SystemMessage2(SystemMsg.YOU_HAVE_EARNED_S2_S1S).addItemName(itemId).addLong(count);
		if(enchantLevel > 0)
			return new SystemMessage2(SystemMsg.YOU_HAVE_OBTAINED_A_S1_S2).addInteger(enchantLevel).addItemName(itemId);
		return new SystemMessage2(SystemMsg.YOU_HAVE_EARNED_S1).addItemName(itemId);
	}

	public static SystemMessage2 obtainItems(ItemInstance item)
	{
		return obtainItems(item.getItemId(), item.getCount(), item.isEquipable() ? item.getEnchantLevel() : 0);
	}

	public static SystemMessage2 obtainItemsBy(int itemId, long count, int enchantLevel, Creature target)
	{
		if(count > 1)
			return new SystemMessage2(SystemMsg.C1_HAS_OBTAINED_S3_S2).addName(target).addItemName(itemId).addLong(count);
		if(enchantLevel > 0)
			return new SystemMessage2(SystemMsg.C1_HAS_OBTAINED_S2S3).addName(target).addInteger(enchantLevel).addItemName(itemId);
		return new SystemMessage2(SystemMsg.C1_HAS_OBTAINED_S2).addName(target).addItemName(itemId);
	}

	public static SystemMessage2 obtainItemsBy(ItemInstance item, Creature target)
	{
		return obtainItemsBy(item.getItemId(), item.getCount(), item.isEquipable() ? item.getEnchantLevel() : 0, target);
	}

	public static SystemMessage2 removeItems(int itemId, long count)
	{
		if(itemId == 57)
			return new SystemMessage2(SystemMsg.S1_ADENA_DISAPPEARED).addLong(count);
		if(count > 1)
			return new SystemMessage2(SystemMsg.S2_S1_HAS_DISAPPEARED).addItemName(itemId).addLong(count);
		return new SystemMessage2(SystemMsg.S1_HAS_DISAPPEARED).addItemName(itemId);
	}

	public static SystemMessage2 removeItems(ItemInstance item)
	{
		return removeItems(item.getItemId(), item.getCount());
	}

	@Override
	protected void writeImpl()
	{
		writeC(0x62);
		writeElements();
	}
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\SystemMessage2.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\ActionFail.java>
package l2ft.gameserver.network.l2.s2c;

public class ActionFail extends L2GameServerPacket
{
	public static final L2GameServerPacket STATIC = new ActionFail();

	@Override
	protected final void writeImpl()
	{
		writeC(0x1f);
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\ActionFail.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\MyTargetSelected.java>
package l2ft.gameserver.network.l2.s2c;

/**
 *
 * <p>
 * sample  b9 73 5d 30 49 01 00 00 00 00 00
 * <p>
 * format dhd	(objectid, color, unk)
 * <p>
 * color 	-xx -> -9 	red<p>
 * 			-8  -> -6	light-red<p>
 * 			-5	-> -3	yellow<p>
 * 			-2	-> 2    white<p>
 * 			 3	-> 5	green<p>
 * 			 6	-> 8	light-blue<p>
 * 			 9	-> xx	blue<p>
 * <p>
 * usually the color equals the level difference to the selected target
 */
public class MyTargetSelected extends L2GameServerPacket
{
	private int _objectId;
	private int _color;

	/**
	 * @param int objectId of the target
	 * @param int level difference to the target. name color is calculated from that
	 */
	public MyTargetSelected(int objectId, int color)
	{
		_objectId = objectId;
		_color = color;
	}

	@Override
	protected final void writeImpl()
	{
		writeC(0xb9);
		writeD(_objectId);
		writeH(_color);
		writeD(0x00);
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\MyTargetSelected.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\UserInfo.java>
package l2ft.gameserver.network.l2.s2c;

import l2ft.gameserver.Config;
import l2ft.gameserver.data.xml.holder.NpcHolder;
import l2ft.gameserver.instancemanager.CursedWeaponsManager;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.Zone;
import l2ft.gameserver.model.base.Element;
import l2ft.gameserver.model.base.Experience;
import l2ft.gameserver.model.base.Race;
import l2ft.gameserver.model.base.TeamType;
import l2ft.gameserver.model.entity.events.GlobalEvent;
import l2ft.gameserver.model.items.Inventory;
import l2ft.gameserver.model.matching.MatchingRoom;
import l2ft.gameserver.model.pledge.Alliance;
import l2ft.gameserver.model.pledge.Clan;
import l2ft.gameserver.skills.effects.EffectCubic;
import l2ft.gameserver.utils.Location;

public class UserInfo extends L2GameServerPacket
{
	private boolean can_writeImpl = false, partyRoom;
	private int _runSpd, _walkSpd, _swimRunSpd, _swimWalkSpd, _flRunSpd, _flWalkSpd, _flyRunSpd, _flyWalkSpd, _relation;
	private double move_speed, attack_speed, col_radius, col_height;
	private int[][] _inv;
	private Location _loc, _fishLoc;
	private int obj_id, vehicle_obj_id, _race, sex, base_class, level, curCp, maxCp, _enchant, _weaponFlag;
	private long _exp;
	private int curHp, maxHp, curMp, maxMp, curLoad, maxLoad, rec_left, rec_have;
	private int _str, _con, _dex, _int, _wit, _men, _sp, ClanPrivs, InventoryLimit;
	private int _patk, _patkspd, _pdef, evasion, accuracy, crit, _matk, _matkspd;
	private int _mdef, pvp_flag, karma, hair_style, hair_color, face, gm_commands, fame, vitality;
	private int clan_id, clan_crest_id, ally_id, ally_crest_id, large_clan_crest_id;
	private int private_store, can_crystalize, pk_kills, pvp_kills, class_id, agathion;
	private int _abnormalEffect, _abnormalEffect2, noble, hero, mount_id, cw_level;
	private int name_color, running, pledge_class, pledge_type, title_color, transformation;
	private int defenceFire, defenceWater, defenceWind, defenceEarth, defenceHoly, defenceUnholy;
	private int mount_type;
	private String _name, title;
	private EffectCubic[] cubics;
	private Element attackElement;
	private int attackElementValue;
	private boolean isFlying, _allowMap;
	private int talismans;
	private boolean openCloak;
	private double _expPercent;
	private TeamType _team;

	public UserInfo(Player player)
	{
		if(player.getTransformationName() != null)
		{
			_name = player.getTransformationName();
			title = "";
			clan_crest_id = 0;
			ally_crest_id = 0;
			large_clan_crest_id = 0;
			cw_level = CursedWeaponsManager.getInstance().getLevel(player.getCursedWeaponEquippedId());
		}
		else
		{
			_name = player.getName();

			Clan clan = player.getClan();
			Alliance alliance = clan == null ? null : clan.getAlliance();
			//
			clan_id = clan == null ? 0 : clan.getClanId();
			clan_crest_id = clan == null ? 0 : clan.getCrestId();
			large_clan_crest_id = clan == null ? 0 : clan.getCrestLargeId();
			//
			ally_id = alliance == null ? 0 : alliance.getAllyId();
			ally_crest_id = alliance == null ? 0 : alliance.getAllyCrestId();

			cw_level = 0;
			title = player.getTitle();
		}

		if(player.getPlayerAccess().GodMode && player.isInvisible())
			title += "[I]";
		if(player.isPolymorphed())
			if(NpcHolder.getInstance().getTemplate(player.getPolyId()) != null)
				title += " - " + NpcHolder.getInstance().getTemplate(player.getPolyId()).name;
			else
				title += " - Polymorphed";

		if(player.isMounted())
		{
			_enchant = 0;
			mount_id = player.getMountNpcId() + 1000000;
			mount_type = player.getMountType();
		}
		else
		{
			_enchant = player.getEnchantEffect();
			mount_id = 0;
			mount_type = 0;
		}

		_weaponFlag = player.getActiveWeaponInstance() == null ? 0x14 : 0x28;

		move_speed = player.getMovementSpeedMultiplier();
		_runSpd = (int) (player.getRunSpeed() / move_speed);
		_walkSpd = (int) (player.getWalkSpeed() / move_speed);

		_flRunSpd = 0; // TODO
		_flWalkSpd = 0; // TODO

		if(player.isFlying())
		{
			_flyRunSpd = _runSpd;
			_flyWalkSpd = _walkSpd;
		}
		else
		{
			_flyRunSpd = 0;
			_flyWalkSpd = 0;
		}

		_swimRunSpd = player.getSwimSpeed();
		_swimWalkSpd = player.getSwimSpeed();

		_inv = new int[Inventory.PAPERDOLL_MAX][3];
		for(int PAPERDOLL_ID : Inventory.PAPERDOLL_ORDER)
		{
			_inv[PAPERDOLL_ID][0] = player.getInventory().getPaperdollObjectId(PAPERDOLL_ID);
			_inv[PAPERDOLL_ID][1] = player.getInventory().getPaperdollItemId(PAPERDOLL_ID);
			_inv[PAPERDOLL_ID][2] = player.getInventory().getPaperdollAugmentationId(PAPERDOLL_ID);
		}

		_relation = player.isClanLeader() ? 0x40 : 0;
		for(GlobalEvent e : player.getEvents())
			_relation = e.getUserRelation(player, _relation);

		_loc = player.getLoc();
		obj_id = player.getObjectId();
		vehicle_obj_id = player.isInBoat() ? player.getBoat().getObjectId() : 0x00;
		_race = player.getRace().ordinal();
		sex = player.getSex();
		base_class = player.getPrimaryClass();
		level = player.getLevel();
		_exp = player.getExp();
		_expPercent = Experience.getExpPercent(player.getLevel(), player.getExp());
		_str = player.getSTR();
		_dex = player.getDEX();
		_con = player.getCON();
		_int = player.getINT();
		_wit = player.getWIT();
		_men = player.getMEN();
		curHp = (int) player.getCurrentHp();
		maxHp = player.getMaxHp();
		curMp = (int) player.getCurrentMp();
		maxMp = player.getMaxMp();
		curLoad = player.getCurrentLoad();
		maxLoad = player.getMaxLoad();
		_sp = player.getIntSp();
		_patk = player.getPAtk(null);
		_patkspd = player.getPAtkSpd();
		_pdef = player.getPDef(null);
		evasion = player.getEvasionRate(null);
		accuracy = player.getAccuracy();
		crit = player.getCriticalHit(null, null);
		_matk = player.getMAtk(null, null);
		_matkspd = player.getMAtkSpd();
		_mdef = player.getMDef(null, null);
		pvp_flag = player.getPvpFlag(); // 0=white, 1=purple, 2=purpleblink
		karma = player.getKarma();
		attack_speed = player.getAttackSpeedMultiplier();
		col_radius = player.getColRadius();
		col_height = player.getColHeight();
		hair_style = player.getRace() == Race.kamael ? 0 : player.getHairStyle();
		hair_color = player.getRace() == Race.kamael ? 0 : player.getHairColor();
		face = player.getFace();
		gm_commands = player.isGM() || player.getPlayerAccess().CanUseGMCommand ? 1 : 0;
		// builder level Đ°ĐşŃ‚Đ¸Đ˛Đ¸Ń€Ń�ĐµŃ‚ Đ˛ ĐşĐ»Đ¸ĐµĐ˝Ń‚Đµ Đ°Đ´ĐĽĐ¸Đ˝Ń�ĐşĐ¸Đµ ĐşĐľĐĽĐ°Đ˝Đ´Ń‹
		clan_id = player.getClanId();
		ally_id = player.getAllyId();
		private_store = player.getPrivateStoreType();
		can_crystalize = 1;
		pk_kills = player.getPkKills();
		pvp_kills = player.getPvpKills();
		cubics = player.getCubics().toArray(new EffectCubic[player.getCubics().size()]);
		_abnormalEffect = player.getAbnormalEffect();
		_abnormalEffect2 = player.getAbnormalEffect2();
		ClanPrivs = player.getClanPrivileges();
		rec_left = player.getRecomLeft(); //c2 recommendations remaining
		rec_have = player.getRecomHave(); //c2 recommendations received
		InventoryLimit = player.getInventoryLimit();
		class_id = player.getActiveClass().getFirstClassId();
		maxCp = player.getMaxCp();
		curCp = (int) player.getCurrentCp();
		_team = player.getTeam();
		noble = player.isNoble() || player.isGM() && Config.GM_HERO_AURA ? 1 : 0; //0x01: symbol on char menu ctrl+I
		hero = player.isHero() || player.isGM() && Config.GM_HERO_AURA ? 1 : 0; //0x01: Hero Aura and symbol
		//fishing = _cha.isFishing() ? 1 : 0; // Fishing Mode
		_fishLoc = player.getFishLoc();
		name_color = player.getNameColor();
		running = player.isRunning() ? 0x01 : 0x00; //changes the Speed display on Status Window
		pledge_class = player.getPledgeClass();
		pledge_type = player.getPledgeType();
		title_color = player.getTitleColor();
		transformation = player.getTransformation();
		attackElement = player.getAttackElement();
		attackElementValue = player.getAttack(attackElement);
		defenceFire = player.getDefence(Element.FIRE);
		defenceWater = player.getDefence(Element.WATER);
		defenceWind = player.getDefence(Element.WIND);
		defenceEarth = player.getDefence(Element.EARTH);
		defenceHoly = player.getDefence(Element.HOLY);
		defenceUnholy = player.getDefence(Element.UNHOLY);
		agathion = player.getAgathionId();
		fame = player.getFame();
		vitality = (int) player.getVitality();
		partyRoom = player.getMatchingRoom() != null && player.getMatchingRoom().getType() == MatchingRoom.PARTY_MATCHING && player.getMatchingRoom().getLeader() == player;
		isFlying = player.isInFlyingTransform();
		talismans = player.getTalismanCount();
		openCloak = player.getOpenCloak();
		_allowMap = player.isActionBlocked(Zone.BLOCKED_ACTION_MINIMAP);

		can_writeImpl = true;
	}

	@Override
	protected final void writeImpl()
	{
		if(!can_writeImpl)
			return;

		writeC(0x32);

		writeD(_loc.x);
		writeD(_loc.y);
		writeD(_loc.z + Config.CLIENT_Z_SHIFT);
		writeD(vehicle_obj_id);
		writeD(obj_id);
		writeS(_name);
		writeD(_race);
		writeD(sex);
		writeD(base_class);
		writeD(level);
		writeQ(_exp);
		writeF(_expPercent);
		writeD(_str);
		writeD(_dex);
		writeD(_con);
		writeD(_int);
		writeD(_wit);
		writeD(_men);
		writeD(maxHp);
		writeD(curHp);
		writeD(maxMp);
		writeD(curMp);
		writeD(_sp);
		writeD(curLoad);
		writeD(maxLoad);
		writeD(_weaponFlag);

		for(int PAPERDOLL_ID : Inventory.PAPERDOLL_ORDER)
			writeD(_inv[PAPERDOLL_ID][0]);

		for(int PAPERDOLL_ID : Inventory.PAPERDOLL_ORDER)
			writeD(_inv[PAPERDOLL_ID][1]);

		for(int PAPERDOLL_ID : Inventory.PAPERDOLL_ORDER)
			writeD(_inv[PAPERDOLL_ID][2]);

		writeD(talismans);
		writeD(openCloak ? 0x01 : 0x00);

		writeD(_patk);
		writeD(_patkspd);
		writeD(_pdef);
		writeD(evasion);
		writeD(accuracy);
		writeD(crit);
		writeD(_matk);
		writeD(_matkspd);
		writeD(_patkspd);
		writeD(_mdef);
		writeD(pvp_flag);
		writeD(karma);
		writeD(_runSpd);
		writeD(_walkSpd);
		writeD(_swimRunSpd); // swimspeed
		writeD(_swimWalkSpd); // swimspeed
		writeD(_flRunSpd);
		writeD(_flWalkSpd);
		writeD(_flyRunSpd);
		writeD(_flyWalkSpd);
		writeF(move_speed);
		writeF(attack_speed);
		writeF(col_radius);
		writeF(col_height);
		writeD(hair_style);
		writeD(hair_color);
		writeD(face);
		writeD(gm_commands);
		writeS(title);
		writeD(clan_id);
		writeD(clan_crest_id);
		writeD(ally_id);
		writeD(ally_crest_id);
		// 0x40 leader rights
		// siege flags: attacker - 0x180 sword over name, defender - 0x80 shield, 0xC0 crown (|leader), 0x1C0 flag (|leader)
		writeD(_relation);
		writeC(mount_type); // mount type
		writeC(private_store);
		writeC(can_crystalize);
		writeD(pk_kills);
		writeD(pvp_kills);
		writeH(cubics.length);
		for(EffectCubic cubic : cubics)
			writeH(cubic == null ? 0 : cubic.getId());
		writeC(partyRoom ? 0x01 : 0x00); //1-find party members
		writeD(_abnormalEffect);
		writeC(isFlying ? 0x02 : 0x00);
		writeD(ClanPrivs);
		writeH(rec_left);
		writeH(rec_have);
		writeD(mount_id);
		writeH(InventoryLimit);
		writeD(class_id);
		writeD(0x00); // special effects? circles around player...
		writeD(maxCp);
		writeD(curCp);
		writeC(_enchant);
		writeC(_team.ordinal());
		writeD(large_clan_crest_id);
		writeC(noble);
		writeC(hero);
		writeC(0x00);
		writeD(_fishLoc.x);
		writeD(_fishLoc.y);
		writeD(_fishLoc.z);
		writeD(name_color);
		writeC(running);
		writeD(pledge_class);
		writeD(pledge_type);
		writeD(title_color);
		writeD(cw_level);
		writeD(transformation); // Transformation id

		// AttackElement (0 - Fire, 1 - Water, 2 - Wind, 3 - Earth, 4 - Holy, 5 - Dark, -2 - None)
		writeH(attackElement.getId());
		writeH(attackElementValue); // AttackElementValue
		writeH(defenceFire); // DefAttrFire
		writeH(defenceWater); // DefAttrWater
		writeH(defenceWind); // DefAttrWind
		writeH(defenceEarth); // DefAttrEarth
		writeH(defenceHoly); // DefAttrHoly
		writeH(defenceUnholy); // DefAttrUnholy

		writeD(agathion);

		// T2 Starts
		writeD(fame); // Fame
		writeD(_allowMap ? 1 : 0); // Minimap on Hellbound

		writeD(vitality); // Vitality Points
		writeD(_abnormalEffect2);
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\UserInfo.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\ServerClose.java>
package l2ft.gameserver.network.l2.s2c;

public class ServerClose extends L2GameServerPacket
{
	public static final L2GameServerPacket STATIC = new ServerClose();

	@Override
	protected void writeImpl()
	{
		writeC(0x20);
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\network\l2\s2c\ServerClose.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\ThreadPoolManager.java>
// Java/l2ft/gameserver/ThreadPoolManager.java
package l2ft.gameserver;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import l2ft.commons.threading.LoggingRejectedExecutionHandler;
import l2ft.commons.threading.PriorityThreadFactory;
import l2ft.commons.threading.RunnableImpl;
import l2ft.commons.threading.RunnableStatsWrapper;

public class ThreadPoolManager
{
	private static final long MAX_DELAY = TimeUnit.NANOSECONDS.toMillis(Long.MAX_VALUE - System.nanoTime()) / 2;

	private static final ThreadPoolManager _instance = new ThreadPoolManager();

	public static ThreadPoolManager getInstance()
	{
		return _instance;
	}

	private final ScheduledThreadPoolExecutor _scheduledExecutor;
	private final ThreadPoolExecutor _executor;

	private boolean _shutdown;

	private ThreadPoolManager()
	{
		_scheduledExecutor = new ScheduledThreadPoolExecutor(Config.SCHEDULED_THREAD_POOL_SIZE, new PriorityThreadFactory("ScheduledThreadPool", Thread.NORM_PRIORITY), new LoggingRejectedExecutionHandler());
		_executor = new ThreadPoolExecutor(Config.EXECUTOR_THREAD_POOL_SIZE, Integer.MAX_VALUE, 5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new PriorityThreadFactory("ThreadPoolExecutor", Thread.NORM_PRIORITY), new LoggingRejectedExecutionHandler());

		//Очистка каждые 5 минут
		scheduleAtFixedRate(new RunnableImpl()
		{
			@Override
			public void runImpl()
			{
				_scheduledExecutor.purge();
				_executor.purge();
			}
		}, 300000L, 300000L);
	}

	private long validate(long delay)
	{
		return Math.max(0, Math.min(MAX_DELAY, delay));
	}

	public boolean isShutdown()
	{
		return _shutdown;
	}

	public Runnable wrap(Runnable r)
	{
		return Config.ENABLE_RUNNABLE_STATS ? RunnableStatsWrapper.wrap(r) : r;
	}

	public ScheduledFuture<?> schedule(Runnable r, long delay)
	{
		return _scheduledExecutor.schedule(wrap(r), validate(delay), TimeUnit.MILLISECONDS);
	}

	public ScheduledFuture<?> scheduleAtFixedRate(Runnable r, long initial, long delay)
	{
		return _scheduledExecutor.scheduleAtFixedRate(wrap(r), validate(initial), validate(delay), TimeUnit.MILLISECONDS);
	}

	public ScheduledFuture<?> scheduleAtFixedDelay(Runnable r, long initial, long delay)
	{
		return _scheduledExecutor.scheduleWithFixedDelay(wrap(r), validate(initial), validate(delay), TimeUnit.MILLISECONDS);
	}

	public void execute(Runnable r)
	{
		_executor.execute(wrap(r));
	}

	public void shutdown() throws InterruptedException
	{
		_shutdown = true;
		try
		{
			_scheduledExecutor.shutdown();
			_scheduledExecutor.awaitTermination(10, TimeUnit.SECONDS);
		}
		finally
		{
			_executor.shutdown();
			_executor.awaitTermination(1, TimeUnit.MINUTES);
		}
	}

	public CharSequence getStats()
	{
		StringBuilder list = new StringBuilder();

		list.append("ScheduledThreadPool\n");
		list.append("=================================================\n");
		list.append("\tgetActiveCount: ...... ").append(_scheduledExecutor.getActiveCount()).append("\n");
		list.append("\tgetCorePoolSize: ..... ").append(_scheduledExecutor.getCorePoolSize()).append("\n");
		list.append("\tgetPoolSize: ......... ").append(_scheduledExecutor.getPoolSize()).append("\n");
		list.append("\tgetLargestPoolSize: .. ").append(_scheduledExecutor.getLargestPoolSize()).append("\n");
		list.append("\tgetMaximumPoolSize: .. ").append(_scheduledExecutor.getMaximumPoolSize()).append("\n");
		list.append("\tgetCompletedTaskCount: ").append(_scheduledExecutor.getCompletedTaskCount()).append("\n");
		list.append("\tgetQueuedTaskCount: .. ").append(_scheduledExecutor.getQueue().size()).append("\n");
		list.append("\tgetTaskCount: ........ ").append(_scheduledExecutor.getTaskCount()).append("\n");
		list.append("ThreadPoolExecutor\n");
		list.append("=================================================\n");
		list.append("\tgetActiveCount: ...... ").append(_executor.getActiveCount()).append("\n");
		list.append("\tgetCorePoolSize: ..... ").append(_executor.getCorePoolSize()).append("\n");
		list.append("\tgetPoolSize: ......... ").append(_executor.getPoolSize()).append("\n");
		list.append("\tgetLargestPoolSize: .. ").append(_executor.getLargestPoolSize()).append("\n");
		list.append("\tgetMaximumPoolSize: .. ").append(_executor.getMaximumPoolSize()).append("\n");
		list.append("\tgetCompletedTaskCount: ").append(_executor.getCompletedTaskCount()).append("\n");
		list.append("\tgetQueuedTaskCount: .. ").append(_executor.getQueue().size()).append("\n");
		list.append("\tgetTaskCount: ........ ").append(_executor.getTaskCount()).append("\n");

		return list;
	}
}
// EOF Java/l2ft/gameserver/ThreadPoolManager.java

</C:\l2sq\Pac Project\Java\l2ft\gameserver\ThreadPoolManager.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\PlayerGroup.java>
package l2ft.gameserver.model;

import java.util.Iterator;

import l2ft.commons.collections.EmptyIterator;
import l2ft.gameserver.network.l2.components.IStaticPacket;

/**
 * @author VISTALL
 * @date 14:03/22.06.2011
 */
public interface PlayerGroup extends Iterable<Player>
{
	public static final PlayerGroup EMPTY = new PlayerGroup()
	{
		@Override
		public void broadCast(IStaticPacket... packet)
		{

		}

		@Override
		public Iterator<Player> iterator()
		{
			return EmptyIterator.getInstance();
		}
	};

	void broadCast(IStaticPacket... packet);
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\PlayerGroup.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\dao\CharacterDAO.java>
package l2ft.gameserver.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import org.apache.commons.lang3.StringUtils;
import l2ft.commons.dbutils.DbUtils;
import l2ft.gameserver.database.DatabaseFactory;
import l2ft.gameserver.model.Player;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CharacterDAO {
	private static final Logger _log = LoggerFactory.getLogger(CharacterDAO.class);

	private static CharacterDAO _instance = new CharacterDAO();

	public static CharacterDAO getInstance() {
		return _instance;
	}

	public void deleteCharByObjId(int objid) {
		if (objid < 0) {
			return;
		}
		Connection con = null;
		PreparedStatement statement = null;
		try {
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("DELETE FROM characters WHERE obj_Id=?");
			statement.setInt(1, objid);
			statement.execute();
		} catch (Exception e) {
			_log.error("deleteCharByObjId: ", e);
		} finally {
			DbUtils.closeQuietly(con, statement);
		}
	}

	public boolean insert(Player player) {
		Connection con = null;
		PreparedStatement statement = null;
		try {
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement(
					"INSERT INTO `characters` (account_name, obj_Id, char_name, face, hairStyle, hairColor, sex, karma, pvpkills, pkkills, clanid, createtime, deletetime, title, accesslevel, online, leaveclan, deleteclan, nochannel, pledge_type, pledge_rank, lvl_joined_academy, apprentice) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
			statement.setString(1, player.getAccountName());
			statement.setInt(2, player.getObjectId());
			statement.setString(3, player.getName());
			statement.setInt(4, player.getFace());
			statement.setInt(5, player.getHairStyle());
			statement.setInt(6, player.getHairColor());
			statement.setInt(7, player.getSex());
			statement.setInt(8, player.getKarma());
			statement.setInt(9, player.getPvpKills());
			statement.setInt(10, player.getPkKills());
			statement.setInt(11, player.getClanId());
			statement.setLong(12, player.getCreateTime() / 1000);
			statement.setInt(13, player.getDeleteTimer());
			statement.setString(14, player.getTitle());
			statement.setInt(15, player.getAccessLevel());
			statement.setInt(16, player.isOnline() ? 1 : 0);
			statement.setLong(17, player.getLeaveClanTime() / 1000);
			statement.setLong(18, player.getDeleteClanTime() / 1000);
			statement.setLong(19, 0);
			statement.setInt(20, player.getPledgeType());
			statement.setInt(21, player.getPowerGrade());
			statement.setInt(22, player.getLvlJoinedAcademy());
			statement.setInt(23, player.getApprentice());
			statement.executeUpdate();
			DbUtils.close(statement);

			statement = con.prepareStatement(
					"INSERT INTO character_subclasses (char_obj_id, class_id, exp, sp, curHp, curMp, curCp, maxHp, maxMp, maxCp, level, active, isBase, death_penalty, certification) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
			statement.setInt(1, player.getObjectId());
			statement.setInt(2, player.getTemplate().classId.getId());
			statement.setInt(3, 0);
			statement.setInt(4, 0);
			statement.setDouble(5,
					player.getTemplate().baseHpMax + player.getTemplate().lvlHpAdd + player.getTemplate().lvlHpMod);
			statement.setDouble(6,
					player.getTemplate().baseMpMax + player.getTemplate().lvlMpAdd + player.getTemplate().lvlMpMod);
			statement.setDouble(7,
					player.getTemplate().baseCpMax + player.getTemplate().lvlCpAdd + player.getTemplate().lvlCpMod);
			statement.setDouble(8,
					player.getTemplate().baseHpMax + player.getTemplate().lvlHpAdd + player.getTemplate().lvlHpMod);
			statement.setDouble(9,
					player.getTemplate().baseMpMax + player.getTemplate().lvlMpAdd + player.getTemplate().lvlMpMod);
			statement.setDouble(10,
					player.getTemplate().baseCpMax + player.getTemplate().lvlCpAdd + player.getTemplate().lvlCpMod);
			statement.setInt(11, 1);
			statement.setInt(12, 1);
			statement.setInt(13, 1);
			statement.setInt(14, 0);
			statement.setInt(15, 0);
			statement.executeUpdate();
		} catch (final Exception e) {
			_log.error("insert: ", e);
			return false;
		} finally {
			DbUtils.closeQuietly(con, statement);
		}
		return true;
	}

	/**
	 * Fetch the desired_rec_have from the 'acp_players' table.
	 * We do NOT prefix the schema, so we rely on the DB's default schema.
	 */
	public int getDesiredRecHave(Player player) {
		int desiredRecHave = -1;
		String accountName = player.getAccountName();
		Connection con = null;
		PreparedStatement ps = null;
		ResultSet rs = null;

		try {
			con = DatabaseFactory.getInstance().getConnection();
			ps = con.prepareStatement("SELECT desired_rec_have FROM l2sq.acp_players WHERE account = ?");
			ps.setString(1, accountName);
			rs = ps.executeQuery();
			if (rs.next()) {
				desiredRecHave = rs.getInt("desired_rec_have");
			}
		} catch (Exception e) {
			_log.warn("getDesiredRecHave() failed for account {}: {}", accountName, e.getMessage());
		} finally {
			DbUtils.closeQuietly(con, ps, rs);
		}
		return desiredRecHave;
	}

	/**
	 * If you want to store the rec_have in 'characters', here's an example method.
	 */
	public void updateRecHaveInCharacters(Player player, int newRecHave) {
		Connection con = null;
		PreparedStatement ps = null;
		try {
			con = DatabaseFactory.getInstance().getConnection();
			ps = con.prepareStatement("UPDATE characters SET rec_have=? WHERE obj_Id=?");
			ps.setInt(1, newRecHave);
			ps.setInt(2, player.getObjectId());
			ps.executeUpdate();
		} catch (Exception e) {
			// We use a simpler overload, e.g. (String msg, Throwable t)
			// Or a single string with + concatenation
			_log.warn("updateRecHaveInCharacters() failed for player "
					+ player.getName()
					+ ", recHave=" + newRecHave, e);
		} finally {
			DbUtils.closeQuietly(con, ps);
		}
	}

	public int getObjectIdByName(String name) {
		int result = 0;
		Connection con = null;
		PreparedStatement statement = null;
		ResultSet rset = null;
		try {
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("SELECT obj_Id FROM characters WHERE char_name=?");
			statement.setString(1, name);
			rset = statement.executeQuery();
			if (rset.next()) {
				result = rset.getInt(1);
			}
		} catch (Exception e) {
			_log.error("getObjectIdByName(String): ", e);
		} finally {
			DbUtils.closeQuietly(con, statement, rset);
		}
		return result;
	}

	public String getNameByObjectId(int objectId) {
		String result = StringUtils.EMPTY;
		Connection con = null;
		PreparedStatement statement = null;
		ResultSet rset = null;
		try {
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("SELECT char_name FROM characters WHERE obj_Id=?");
			statement.setInt(1, objectId);
			rset = statement.executeQuery();
			if (rset.next()) {
				result = rset.getString(1);
			}
		} catch (Exception e) {
			_log.error("getNameByObjectId(int): ", e);
		} finally {
			DbUtils.closeQuietly(con, statement, rset);
		}
		return result;
	}

	public int accountCharNumber(String account) {
		int number = 0;
		Connection con = null;
		PreparedStatement statement = null;
		ResultSet rset = null;
		try {
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("SELECT COUNT(char_name) FROM characters WHERE account_name=?");
			statement.setString(1, account);
			rset = statement.executeQuery();
			if (rset.next()) {
				number = rset.getInt(1);
			}
		} catch (Exception e) {
			_log.error("accountCharNumber: ", e);
		} finally {
			DbUtils.closeQuietly(con, statement, rset);
		}
		return number;
	}
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\dao\CharacterDAO.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\dao\EffectsDAO.java>
package l2ft.gameserver.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.List;

import l2ft.commons.dbutils.DbUtils;
import l2ft.gameserver.database.DatabaseFactory;
import l2ft.gameserver.model.Effect;
import l2ft.gameserver.model.Playable;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.model.instances.SummonInstance;
import l2ft.gameserver.skills.EffectType;
import l2ft.gameserver.skills.effects.EffectTemplate;
import l2ft.gameserver.stats.Env;
import l2ft.gameserver.tables.SkillTable;
import l2ft.gameserver.utils.SqlBatch;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author VISTALL
 * @date 13:01/02.02.2011
 */
public class EffectsDAO
{
	private static final int SUMMON_SKILL_OFFSET = 100000;
	private static final Logger _log = LoggerFactory.getLogger(EffectsDAO.class);
	private static final EffectsDAO _instance = new EffectsDAO();

	EffectsDAO()
	{
		//
	}

	public static EffectsDAO getInstance()
	{
		return _instance;
	}

	public void restoreEffects(Playable playable)
	{
		int objectId, id;
		if(playable.isPlayer())
		{
			objectId = playable.getObjectId();
			id = playable.getPlayer().getFirstClassId();
		}
		else if(playable.isSummon())
		{
			objectId = playable.getPlayer().getObjectId();
			id = ((SummonInstance)playable).getEffectIdentifier() + SUMMON_SKILL_OFFSET;
		}
		else
			return;

		Connection con = null;
		PreparedStatement statement = null;
		ResultSet rset = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("SELECT `skill_id`,`skill_level`,`effect_count`,`effect_cur_time`,`duration` FROM `character_effects_save` WHERE `object_id`=? AND `id`=? ORDER BY `order` ASC");
			statement.setInt(1, objectId);
			statement.setInt(2, id);
			rset = statement.executeQuery();
			while(rset.next())
			{
				int skillId = rset.getInt("skill_id");
				int skillLvl = rset.getInt("skill_level");
				int effectCount = rset.getInt("effect_count");
				long effectCurTime = rset.getLong("effect_cur_time");
				long duration = rset.getLong("duration");

				Skill skill = SkillTable.getInstance().getInfo(skillId, skillLvl);
				if(skill == null)
					continue;

				for(EffectTemplate et : skill.getEffectTemplates())
				{
					if(et == null)
						continue;
					Env env = new Env(playable, playable, skill);
					Effect effect = et.getEffect(env);
					if(effect == null || effect.isOneTime())
						continue;

					effect.setCount(effectCount);
					effect.setPeriod(effectCount == 1 ? duration - effectCurTime : duration);

					playable.getEffectList().addEffect(effect);
				}
			}

			DbUtils.closeQuietly(statement, rset);

			statement = con.prepareStatement("DELETE FROM character_effects_save WHERE object_id = ? AND id=?");
			statement.setInt(1, objectId);
			statement.setInt(2, id);
			statement.execute();
			DbUtils.close(statement);
		}
		catch(final Exception e)
		{
			_log.error("Could not restore active effects data!", e);
		}
		finally
		{
			DbUtils.closeQuietly(con);
		}
	}

	public void deleteEffects(int objectId, int skillId)
	{
		Connection con = null;
		PreparedStatement statement = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.prepareStatement("DELETE FROM character_effects_save WHERE object_id = ? AND id=?");
			statement.setInt(1, objectId);
			statement.setInt(2, SUMMON_SKILL_OFFSET + skillId);
			statement.execute();
		}
		catch(final Exception e)
		{
			_log.error("Could not delete effects active effects data!" + e, e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement);
		}
	}

	public void insert(Playable playable)
	{
		int objectId, id;
		if(playable.isPlayer())
		{
			objectId = playable.getObjectId();
			id = playable.getPlayer().getFirstClassId();
		}
		else if(playable.isSummon())
		{
			objectId = playable.getPlayer().getObjectId();
			id = ((SummonInstance)playable).getEffectIdentifier() + SUMMON_SKILL_OFFSET;
		}
		else
			return;

		List<Effect> effects = playable.getEffectList().getAllEffects();
		if(effects.isEmpty())
			return;

		Connection con = null;
		Statement statement = null;
		try
		{
			con = DatabaseFactory.getInstance().getConnection();
			statement = con.createStatement();

			int order = 0;
			SqlBatch b = new SqlBatch("INSERT IGNORE INTO `character_effects_save` (`object_id`,`skill_id`,`skill_level`,`effect_count`,`effect_cur_time`,`duration`,`order`,`id`) VALUES");

			StringBuilder sb;
			for(Effect effect : effects)
				if(effect != null && effect.isInUse() && !effect.getSkill().isToggle() && effect.getEffectType() != EffectType.HealOverTime && effect.getEffectType() != EffectType.CombatPointHealOverTime)
				{
					if(effect.isSaveable())
					{
						sb = new StringBuilder("(");
						sb.append(objectId).append(",");
						sb.append(effect.getSkill().getId()).append(",");
						sb.append(effect.getSkill().getLevel()).append(",");
						sb.append(effect.getCount()).append(",");
						sb.append(effect.getTime()).append(",");
						sb.append(effect.getPeriod()).append(",");
						sb.append(order).append(",");
						sb.append(id).append(")");
						b.write(sb.toString());
					}
					while((effect = effect.getNext()) != null && effect.isSaveable())
					{
						sb = new StringBuilder("(");
						sb.append(objectId).append(",");
						sb.append(effect.getSkill().getId()).append(",");
						sb.append(effect.getSkill().getLevel()).append(",");
						sb.append(effect.getCount()).append(",");
						sb.append(effect.getTime()).append(",");
						sb.append(effect.getPeriod()).append(",");
						sb.append(order).append(",");
						sb.append(id).append(")");
						b.write(sb.toString());
					}
					order++;
				}

			if(!b.isEmpty())
				statement.executeUpdate(b.close());
		}
		catch(final Exception e)
		{
			_log.error("Could not store active effects data!", e);
		}
		finally
		{
			DbUtils.closeQuietly(con, statement);
		}
	}
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\dao\EffectsDAO.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\tables\SkillTable.java>
package l2ft.gameserver.tables;

import gnu.trove.TIntIntHashMap;
import gnu.trove.TIntObjectHashMap;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.skills.SkillsEngine;

public class SkillTable
{

	private static final SkillTable _instance = new SkillTable();

	private TIntObjectHashMap<Skill> _skills;
	private TIntIntHashMap _maxLevelsTable;
	private TIntIntHashMap _baseLevelsTable;

	public static final SkillTable getInstance()
	{
		return _instance;
	}

	public void load()
	{
		_skills = SkillsEngine.getInstance().loadAllSkills();
		makeLevelsTable();
	}

	public void reload()
	{
		load();
	}

	public Skill getInfo(int skillId, int level)
	{
		return _skills.get(getSkillHashCode(skillId, level));
	}

	public int getMaxLevel(int skillId)
	{
		return _maxLevelsTable.get(skillId);
	}

	public int getBaseLevel(int skillId)
	{
		return _baseLevelsTable.get(skillId);
	}

	public static int getSkillHashCode(Skill skill)
	{
		return SkillTable.getSkillHashCode(skill.getId(), skill.getLevel());
	}

	public static int getSkillHashCode(int skillId, int skillLevel)
	{
		return skillId * 1000 + skillLevel;
	}

	private void makeLevelsTable()
	{
		_maxLevelsTable = new TIntIntHashMap();
		_baseLevelsTable = new TIntIntHashMap();
		for(Object obj : _skills.getValues())
		{
			Skill s = (Skill)obj;
			int skillId = s.getId();
			int level = s.getLevel();
			int maxLevel = _maxLevelsTable.get(skillId);
			if(level > maxLevel)
				_maxLevelsTable.put(skillId, level);
			if(_baseLevelsTable.get(skillId) == 0)
				_baseLevelsTable.put(skillId, s.getBaseLevel());
		}
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\tables\SkillTable.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\effects\EffectTemplate.java>
package l2ft.gameserver.skills.effects;

import java.util.List;

import l2ft.gameserver.model.EffectList;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.Effect;
import l2ft.gameserver.skills.AbnormalEffect;
import l2ft.gameserver.skills.EffectType;
import l2ft.gameserver.stats.Env;
import l2ft.gameserver.stats.StatTemplate;
import l2ft.gameserver.stats.conditions.Condition;
import l2ft.gameserver.templates.StatsSet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class EffectTemplate extends StatTemplate
{
	private static final Logger _log = LoggerFactory.getLogger(EffectTemplate.class);

	public static final EffectTemplate[] EMPTY_ARRAY = new EffectTemplate[0];

	public static final String NO_STACK = "none".intern();
	public static final String HP_RECOVER_CAST = "HpRecoverCast".intern();

	public Condition _attachCond;
	public final double _value;
	public final int _count;
	public final long _period; // in milliseconds
	public AbnormalEffect _abnormalEffect;
	public AbnormalEffect _abnormalEffect2;
	public AbnormalEffect _abnormalEffect3;

	public final EffectType _effectType;

	public final String _stackType;
	public final String _stackType2;
	public final int _stackOrder;
	public final int _displayId;
	public final int _displayLevel;

	public final boolean _applyOnCaster;
	public final boolean _applyOnSummon;
	public final boolean _cancelOnAction;
	public final boolean _isReflectable;
	private final Boolean _isSaveable;
	private final Boolean _isCancelable;
	private final Boolean _isOffensive;

	private final StatsSet _paramSet;
	private final int _chance;

	public EffectTemplate(StatsSet set)
	{
		_value = set.getDouble("value");
		_count = set.getInteger("count", 1) < 0 ? Integer.MAX_VALUE : set.getInteger("count", 1);
		_period = Math.min(Integer.MAX_VALUE, 1000 * (set.getInteger("time", 1) < 0 ? Integer.MAX_VALUE : set.getInteger("time", 1)));
		_abnormalEffect = set.getEnum("abnormal", AbnormalEffect.class);
		_abnormalEffect2 = set.getEnum("abnormal2", AbnormalEffect.class);
		_abnormalEffect3 = set.getEnum("abnormal3", AbnormalEffect.class);
		_stackType = set.getString("stackType", NO_STACK);
		_stackType2 = set.getString("stackType2", NO_STACK);
		_stackOrder = set.getInteger("stackOrder", _stackType.equals(NO_STACK) &&  _stackType2.equals(NO_STACK) ? 1 : 0);
		_applyOnCaster = set.getBool("applyOnCaster", false);
		_applyOnSummon = set.getBool("applyOnSummon", true);
		_cancelOnAction = set.getBool("cancelOnAction", false);
		_isReflectable = set.getBool("isReflectable", true);
		_isSaveable = set.isSet("isSaveable") ? set.getBool("isSaveable") : null;
		_isCancelable = set.isSet("isCancelable") ? set.getBool("isCancelable") : null;
		_isOffensive = set.isSet("isOffensive") ? set.getBool("isOffensive") : null;
		_displayId = set.getInteger("displayId", 0);
		_displayLevel = set.getInteger("displayLevel", 0);
		_effectType = set.getEnum("name", EffectType.class);
		_chance = set.getInteger("chance", Integer.MAX_VALUE);
		_paramSet = set;
	}

	public Effect getEffect(Env env)
	{
		if(_attachCond != null && !_attachCond.test(env))
			return null;
		try
		{
			return _effectType.makeEffect(env, this);
		}
		catch(Exception e)
		{
			_log.error("", e);
		}

		return null;
	}

	public void attachCond(Condition c)
	{
		_attachCond = c;
	}

	public int getCount()
	{
		return _count;
	}

	public long getPeriod()
	{
		return _period;
	}

	public EffectType getEffectType()
	{
		return _effectType;
	}

	public Effect getSameByStackType(List<Effect> list)
	{
		for(Effect ef : list)
			if(ef != null && EffectList.checkStackType(ef.getTemplate(), this))
				return ef;
		return null;
	}

	public Effect getSameByStackType(EffectList list)
	{
		return getSameByStackType(list.getAllEffects());
	}

	public Effect getSameByStackType(Creature actor)
	{
		return getSameByStackType(actor.getEffectList().getAllEffects());
	}

	public StatsSet getParam()
	{
		return _paramSet;
	}

	public int chance(int val)
	{
		return _chance == Integer.MAX_VALUE ? val : _chance;
	}

	public boolean isSaveable(boolean def)
	{
		return _isSaveable != null ? _isSaveable.booleanValue() : def;
	}

	public boolean isCancelable(boolean def)
	{
		return _isCancelable != null ? _isCancelable.booleanValue() : def;
	}

	public boolean isOffensive(boolean def)
	{
		return _isOffensive != null ? _isOffensive.booleanValue() : def;
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\effects\EffectTemplate.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\EffectList.java>
package l2ft.gameserver.model;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Collections;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized EffectList for MVP:
 * - Manages a Creature's list of active Effects.
 * - Basic methods: addEffect, removeEffect, getAllEffects, stopAllEffects, etc.
 * - Omitted advanced slot-limits, concurrency, & advanced searching.
 */
public class EffectList
{
    private static final Logger _log = LoggerFactory.getLogger(EffectList.class);

    private final Creature _actor;
    private List<Effect> _effects;

    public EffectList(Creature owner)
    {
        _actor = owner;
        _effects = new CopyOnWriteArrayList<>();
    }

    public Creature getActor()
    {
        return _actor;
    }

    /** Returns an immutable list of current effects. */
    public List<Effect> getAllEffects()
    {
        if (_effects.isEmpty())
            return Collections.emptyList();
        return Collections.unmodifiableList(_effects);
    }

    /** Adds a new effect. If successful, calls effect.start(). */
    public void addEffect(Effect effect)
    {
        if (effect == null)
            return;
        // Possibly skip duplicates or checks, simplified for MVP
        _effects.add(effect);
        effect.start();
        _actor.updateEffectIcons();
    }

    /** Removes the specified effect from our list. */
    public void removeEffect(Effect effect)
    {
        if (effect == null)
            return;
        if (_effects.remove(effect))
        {
            _actor.updateEffectIcons();
        }
    }

    /** Removes all effects. */
    public void stopAllEffects()
    {
        for (Effect e : _effects)
            e.exit();
        _effects.clear();
        _actor.updateEffectIcons();
    }

    /** Halts effect(s) with the given skill ID. */
    public void stopEffect(int skillId)
    {
        for (Effect e : _effects)
        {
            if (e.getSkill().getId() == skillId)
                e.exit();
        }
    }

    /** Helper to remove effect(s) by skill reference. */
    public void stopEffect(Skill skill)
    {
        if (skill != null)
            stopEffect(skill.getId());
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\EffectList.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\funcs\Func.java>
package l2ft.gameserver.stats.funcs;

import l2ft.gameserver.stats.Env;
import l2ft.gameserver.stats.Stats;
import l2ft.gameserver.stats.conditions.Condition;

/**
 * A Func object is a component of a Calculator created to manage and dynamically calculate the effect of a character property (ex : MAX_HP, REGENERATE_HP_RATE...).
 * In fact, each calculator is a table of Func object in which each Func represents a mathematic function : <BR><BR>
 *
 * FuncAtkAccuracy -> Math.sqrt(_player.getDEX())*6+_player.getLevel()<BR><BR>
 *
 * When the calc method of a calculator is launched, each mathematic function is called according to its priority <B>_order</B>.
 * Indeed, Func with lowest priority order is executed firsta and Funcs with the same order are executed in unspecified order.
 * The result of the calculation is stored in the value property of an Env class instance.<BR><BR>
 *
 */
public abstract class Func implements Comparable<Func>
{
	public static final Func[] EMPTY_FUNC_ARRAY = new Func[0];

	/** Statistics, that is affected by this function (See L2Character.CALCULATOR_XXX constants) */
	public final Stats stat;

	/**
	 * Order of functions calculation.
	 * Functions with lower order are executed first.
	 * Functions with the same order are executed in unspecified order.
	 * Usually add/substruct functions has lowest order,
	 * then bonus/penalty functions (multiplay/divide) are
	 * applied, then functions that do more complex calculations
	 * (non-linear functions).
	 */
	public final int order;

	/**
	 *  Owner can be an armor, weapon, skill, system event, quest, etc
	 *  Used to remove all functions added by this owner.
	 */
	public final Object owner;

	public final double value;

	protected Condition cond;

	public Func(Stats stat, int order, Object owner)
	{
		this(stat, order, owner, 0.);
	}

	public Func(Stats stat, int order, Object owner, double value)
	{
		this.stat = stat;
		this.order = order;
		this.owner = owner;
		this.value = value;
	}

	public void setCondition(Condition cond)
	{
		this.cond = cond;
	}

	/**
	 * Для отладки
	 */
	public Condition getCondition()
	{
		return cond;
	}

	public abstract void calc(Env env);

	@Override
	public int compareTo(Func f) throws NullPointerException
	{
		return order - f.order;
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\funcs\Func.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\funcs\FuncTemplate.java>
package l2ft.gameserver.stats.funcs;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

import l2ft.gameserver.stats.Stats;
import l2ft.gameserver.stats.conditions.Condition;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class FuncTemplate
{
	private static final Logger _log = LoggerFactory.getLogger(FuncTemplate.class);

	public static final FuncTemplate[] EMPTY_ARRAY = new FuncTemplate[0];
	
	public Condition _applyCond;
	public Class<?> _func;
	public Constructor<?> _constructor;
	public Stats _stat;
	public int _order;
	public double _value;

	public FuncTemplate(Condition applyCond, String func, Stats stat, int order, double value)
	{
		_applyCond = applyCond;
		_stat = stat;
		_order = order;
		_value = value;

		try
		{
			_func = Class.forName("l2ft.gameserver.stats.funcs.Func" + func);

			_constructor = _func.getConstructor(new Class[] { Stats.class, // stats to update
					Integer.TYPE, // order of execution
					Object.class, // owner
					Double.TYPE // value for function
			});
		}
		catch(Exception e)
		{
			_log.error("", e);
		}
	}

	public Func getFunc(Object owner)
	{
		try
		{
			Func f = (Func) _constructor.newInstance(_stat, _order, owner, _value);
			if(_applyCond != null)
				f.setCondition(_applyCond);
			return f;
		}
		catch(IllegalAccessException e)
		{
			_log.error("", e);
			return null;
		}
		catch(InstantiationException e)
		{
			_log.error("", e);
			return null;
		}
		catch(InvocationTargetException e)
		{
			_log.error("", e);
			return null;
		}
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\stats\funcs\FuncTemplate.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\skillclasses\MDam.java>
package l2ft.gameserver.skills.skillclasses;

import java.util.List;

import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.stats.Formulas;
import l2ft.gameserver.templates.StatsSet;

public class MDam extends Skill
{
	public MDam(StatsSet set)
	{
		super(set);
	}

	@Override
	public void useSkill(Creature activeChar, List<Creature> targets)
	{
		int sps = isSSPossible() ? (isMagic() ? activeChar.getChargedSpiritShot() : activeChar.getChargedSoulShot() ? 2 : 0) : 0;

		Creature realTarget;
		boolean reflected;

		for(Creature target : targets)
			if(target != null)
			{
				if(target.isDead())
					continue;

				reflected = target.checkReflectSkill(activeChar, this);
				realTarget = reflected ? activeChar : target;

				double damage = Formulas.calcMagicDam(activeChar, realTarget, this, sps);
				if(damage >= 1)
					realTarget.reduceCurrentHp(damage, activeChar, this, true, true, false, true, false, false, true);

				getEffects(activeChar, target, getActivateRate() > 0, false, reflected);
			}

		if(isSuicideAttack())
			activeChar.doDie(null);
		else if(isSSPossible())
			activeChar.unChargeShots(isMagic());
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\skillclasses\MDam.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\skillclasses\PDam.java>
package l2ft.gameserver.skills.skillclasses;

import java.util.List;

import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.FinishRotating;
import l2ft.gameserver.network.l2.s2c.StartRotating;
import l2ft.gameserver.network.l2.s2c.SystemMessage2;
import l2ft.gameserver.stats.Formulas;
import l2ft.gameserver.stats.Formulas.AttackInfo;
import l2ft.gameserver.templates.StatsSet;


public class PDam extends Skill
{
	private final boolean _onCrit;
	private final boolean _directHp;
	private final boolean _turner;
	private final boolean _blow;

	public PDam(StatsSet set)
	{
		super(set);
		_onCrit = set.getBool("onCrit", false);
		_directHp = set.getBool("directHp", false);
		_turner = set.getBool("turner", false);
		_blow = set.getBool("blow", false);
	}

	@Override
	public void useSkill(Creature activeChar, List<Creature> targets)
	{
		boolean ss = activeChar.getChargedSoulShot() && isSSPossible();

		Creature realTarget;
		boolean reflected;

		for(Creature target : targets)
			if(target != null && !target.isDead())
			{
				if(_turner && !target.isInvul())
				{
					target.broadcastPacket(new StartRotating(target, target.getHeading(), 1, 65535));
					target.broadcastPacket(new FinishRotating(target, activeChar.getHeading(), 65535));
					target.setHeading(activeChar.getHeading());
					target.sendPacket(new SystemMessage2(SystemMsg.S1S_EFFECT_CAN_BE_FELT).addSkillName(_displayId, _displayLevel));
				}

				reflected = target.checkReflectSkill(activeChar, this);
				realTarget = reflected ? activeChar : target;

				AttackInfo info = Formulas.calcPhysDam(activeChar, realTarget, this, false, _blow, ss, _onCrit);

				if (info.lethal_dmg > 0)
					realTarget.reduceCurrentHp(info.lethal_dmg, activeChar, this, true, true, false, false, false, false, false);

				if(!info.miss || info.damage >= 1)
					realTarget.reduceCurrentHp(info.damage, activeChar, this, true, true, info.lethal ? false : _directHp, true, false, false, getPower() != 0);

				if(!reflected)
					realTarget.doCounterAttack(this, activeChar, _blow);

				getEffects(activeChar, target, getActivateRate() > 0, false, reflected);
			}

		if(isSuicideAttack())
			activeChar.doDie(null);
		else if(isSSPossible())
			activeChar.unChargeShots(isMagic());
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\skills\skillclasses\PDam.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\entity\events\GlobalEvent.java>
// ============================================================================
// ==================== MINIMIZED GlobalEvent.java ============================
// ============================================================================
package l2ft.gameserver.model.entity.events;

import l2ft.commons.logging.LoggerObject;

/**
 * Minimized GlobalEvent class for the MVP.
 * Skips most advanced logic about multiple events, items, reflection, etc.
 */
public abstract class GlobalEvent extends LoggerObject
{
    protected final int _id;
    protected final String _name;

    public GlobalEvent(int id, String name)
    {
        _id = id;
        _name = name;
    }

    /** Called once at server start or event load. */
    public void initEvent()
    {
        // Minimal
        reCalcNextTime(true);
    }

    /** Called to start the event logic. */
    public void startEvent()
    {
        // Minimal
    }

    /** Called to stop the event logic. */
    public void stopEvent()
    {
        // Minimal
    }

    /** In real code, calculates next start time. */
    public abstract void reCalcNextTime(boolean onInit);

    /** Returns next start time in ms. Here, 0 for MVP stub. */
    protected abstract long startTimeMillis();

    public int getId()
    {
        return _id;
    }

    public String getName()
    {
        return _name;
    }

    public boolean isInProgress()
    {
        return false;
    }
}
// ============================================================================
// ================= END MINIMIZED GlobalEvent.java ===========================
// ============================================================================

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\entity\events\GlobalEvent.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\geodata\GeoEngine.java>
package l2ft.gameserver.geodata;

import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.utils.Location;

/**
 * Minimized GeoEngine class for the MVP.
 * 
 * In this MVP version, we provide basic stubs for geodata checks:
 * - getHeight(...) always returns the input z (no geodata height).
 * - canMoveToCoord(...) always returns true (no real movement blocking).
 * - canSeeTarget(...) and canSeeCoord(...) always return true (no line-of-sight logic).
 *
 * If needed in the future, the logic can be expanded or replaced with actual geodata checks.
 */
public class GeoEngine
{
    public static int getHeight(int x, int y, int z, int geoIndex)
    {
        // For our MVP, we do not apply geodata height logic.
        return z;
    }

    public static boolean canMoveToCoord(int x, int y, int z, int tx, int ty, int tz, int geoIndex)
    {
        // MVP stub: always allow movement
        return true;
    }

    public static boolean canSeeCoord(int x, int y, int z, int tx, int ty, int tz, boolean air, int geoIndex)
    {
        // MVP stub: always allow line of sight
        return true;
    }

    public static boolean canSeeTarget(GameObject actor, GameObject target, boolean air)
    {
        // MVP stub: always allow seeing the target
        return true;
    }

    // Optionally, if other classes in the MVP call getType() or getNSWE(), you can keep stubs:

    public static short getType(int x, int y, int geoIndex)
    {
        // No real geodata, so 0
        return 0;
    }

    public static byte getNSWE(int x, int y, int z, int geoIndex)
    {
        // If needed, return full passability
        return 0x0F; // 0x0F represents NSWE_ALL in the original code.
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\geodata\GeoEngine.java>

<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\instances\NpcInstance.java>
package l2ft.gameserver.model.instances;

import l2ft.commons.lang.reference.HardReference;
import l2ft.gameserver.ThreadPoolManager;
import l2ft.gameserver.ai.CharacterAI;
import l2ft.gameserver.ai.CtrlIntention;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.model.Spawner;
import l2ft.gameserver.model.World;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.MyTargetSelected;
import l2ft.gameserver.network.l2.s2c.ValidateLocation;
import l2ft.gameserver.stats.Stats;
import l2ft.gameserver.templates.npc.NpcTemplate;
import l2ft.gameserver.utils.ItemFunctions;
import l2ft.gameserver.utils.Location;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized NpcInstance class:
 * - Basic onAction, onDeath, spawn, aggression, dropping items logic
 * - Removes advanced quest interactions, expansions, random animations, etc.
 */
public class NpcInstance extends Creature {
    private static final Logger _log = LoggerFactory.getLogger(NpcInstance.class);

    // Basic references
    private Spawner _spawn;
    private Location _spawnedLoc = new Location();
    private long _dieTime;

    // Aggro
    private int _personalAggroRange = -1;
    private boolean _unAggred = false;

    // ----------------------------
    //    CONSTRUCTOR & GETTERS
    // ----------------------------

    public NpcInstance(int objectId, NpcTemplate template) {
        super(objectId);
        _template = template;
        setName(template.name);
        setTitle(template.title);
    }

    @SuppressWarnings("unchecked")
    @Override
    public HardReference<NpcInstance> getRef() {
        return (HardReference<NpcInstance>) super.getRef();
    }

    @Override
    public NpcTemplate getTemplate() {
        return (NpcTemplate) _template;
    }

    public Spawner getSpawn() {
        return _spawn;
    }

    public void setSpawn(Spawner spawn) {
        _spawn = spawn;
    }

    public Location getSpawnedLoc() {
        return _spawnedLoc;
    }

    public void setSpawnedLoc(Location loc) {
        _spawnedLoc = loc;
    }

    public long getDeadTime() {
        return _dieTime <= 0L ? 0L : System.currentTimeMillis() - _dieTime;
    }

    // ----------------------------
    //       AGGRESSION
    // ----------------------------

    public boolean isAggressive() {
        return getAggroRange() > 0;
    }

    public int getAggroRange() {
        if (_unAggred)
            return 0;
        if (_personalAggroRange >= 0)
            return _personalAggroRange;
        return getTemplate().aggroRange;
    }

    public void setAggroRange(int aggroRange) {
        _personalAggroRange = aggroRange;
    }

    public void setUnAggred(boolean state) {
        _unAggred = state;
    }

    @Override
    public boolean isAttackable(Creature attacker) {
        // Called by AI to see if it can be attacked
        return true;
    }

    @Override
    public boolean isAutoAttackable(Creature attacker) {
        // For standard NPC, default to false
        return false;
    }

    // ----------------------------
    //        BASIC AI
    // ----------------------------

    @Override
    public CharacterAI getAI() {
        if (_ai == null) {
            synchronized (this) {
                if (_ai == null) {
                    _ai = getTemplate().getNewAI(this);
                }
            }
        }
        return _ai;
    }

    // ----------------------------
    //      SPAWN/RESPAWN
    // ----------------------------

    @Override
    protected void onSpawn() {
        super.onSpawn();
        _dieTime = 0L;
        // Start AI if region is active or if it's a global AI
        if (getAI().isGlobalAI() || isActiveRegion()) {
            getAI().startAITask();
        }
        // Possibly notify active intention
        getAI().notifyEvent(CtrlIntention.AI_INTENTION_ACTIVE, null, null);
    }

    protected boolean isActiveRegion() {
        // In a minimized version, assume always active
        return true;
    }

    // ----------------------------
    //        ON ACTION
    // ----------------------------

    @Override
    public void onAction(Player player, boolean shift) {
        // Basic targeting logic
        if (player.getTarget() != this) {
            player.setTarget(this);
            // Show selection
            player.sendPacket(new MyTargetSelected(getObjectId(), 0));
            player.sendPacket(new ValidateLocation(this));
            return;
        }

        // If auto-attackable, command attack
        if (isAutoAttackable(player)) {
            player.getAI().Attack(this, false, shift);
        } else {
            // Otherwise, do nothing special
            player.sendActionFailed();
        }
    }

    // ----------------------------
    //         DEATH/DECAY
    // ----------------------------

    @Override
    protected void onDeath(Creature killer) {
        _dieTime = System.currentTimeMillis();
        super.onDeath(killer);
        // Optionally schedule decay
        startDecay(8000L);
    }

    @Override
    public void doDie(Creature killer) {
        if (!isDead.compareAndSet(false, true))
            return;
        onDeath(killer);
    }

    protected void startDecay(long delay) {
        ThreadPoolManager.getInstance().schedule(this::doDecay, delay);
    }

    protected void doDecay() {
        if (_spawn != null) {
            _spawn.decreaseCount(this);
        } else {
            deleteMe();
        }
    }

    // ----------------------------
    //         ITEM DROPS
    // ----------------------------

    public void dropItem(Player lastAttacker, int itemId, long itemCount) {
        if (itemCount == 0 || lastAttacker == null)
            return;
        for (long i = 0; i < itemCount; i++) {
            // Summarily create an item
            var item = ItemFunctions.createItem(itemId);
            if (item.isStackable()) {
                item.setCount(itemCount);
                i = itemCount; // break loop
            }
            // The actual pickup or auto-loot
            lastAttacker.doAutoLootOrDrop(item, this);
        }
    }

    // ----------------------------
    //    REWARDS & STAT OVERRIDES
    // ----------------------------

    public long getExpReward() {
        return (long) calcStat(Stats.EXP, getTemplate().rewardExp, null, null);
    }

    public long getSpReward() {
        return (long) calcStat(Stats.SP, getTemplate().rewardSp, null, null);
    }

    // ----------------------------
    //          UTILITY
    // ----------------------------

    @Override
    public String toString() {
        return getNpcId() + " " + getName();
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\instances\NpcInstance.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\PlayableAI.java>
package l2ft.gameserver.ai;

import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_ACTIVE;
import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_ATTACK;
import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_CAST;
import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_FOLLOW;
import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_INTERACT;
import static l2ft.gameserver.ai.CtrlIntention.AI_INTENTION_PICK_UP;

import java.util.concurrent.ScheduledFuture;

import l2ft.commons.threading.RunnableImpl;
import l2ft.gameserver.ThreadPoolManager;
import l2ft.gameserver.cache.Msg;
import l2ft.gameserver.geodata.GeoEngine;
import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.model.Playable;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.model.Skill.NextAction;
import l2ft.gameserver.model.Skill.SkillType;
import l2ft.gameserver.model.Summon;
import l2ft.gameserver.network.l2.components.SystemMsg;
import l2ft.gameserver.network.l2.s2c.MyTargetSelected;
import l2ft.gameserver.utils.Location;


public class PlayableAI extends CharacterAI
{
	private volatile int thinking = 0; // to prevent recursive thinking

	protected Object _intention_arg0 = null, _intention_arg1 = null;
	protected Skill _skill;

	private nextAction _nextAction;
	private Object _nextAction_arg0;
	private Object _nextAction_arg1;
	private boolean _nextAction_arg2;
	private boolean _nextAction_arg3;

	protected boolean _forceUse;
	private boolean _dontMove;

	private ScheduledFuture<?> _followTask;

	public PlayableAI(Playable actor)
	{
		super(actor);
	}

	public enum nextAction
	{
		ATTACK,
		CAST,
		MOVE,
		REST,
		PICKUP,
		INTERACT,
		COUPLE_ACTION
	}

	@Override
	public void changeIntention(CtrlIntention intention, Object arg0, Object arg1)
	{
		super.changeIntention(intention, arg0, arg1);
		_intention_arg0 = arg0;
		_intention_arg1 = arg1;
	}

	@Override
	public void setIntention(CtrlIntention intention, Object arg0, Object arg1)
	{
		_intention_arg0 = null;
		_intention_arg1 = null;
		super.setIntention(intention, arg0, arg1);
	}

	@Override
	protected void onIntentionCast(Skill skill, Creature target)
	{
		_skill = skill;
		super.onIntentionCast(skill, target);
	}

	@Override
	public void setNextAction(nextAction action, Object arg0, Object arg1, boolean arg2, boolean arg3)
	{
		_nextAction = action;
		_nextAction_arg0 = arg0;
		_nextAction_arg1 = arg1;
		_nextAction_arg2 = arg2;
		_nextAction_arg3 = arg3;
	}

	public boolean setNextIntention()
	{
		nextAction nextAction = _nextAction;
		Object nextAction_arg0 = _nextAction_arg0;
		Object nextAction_arg1 = _nextAction_arg1;
		boolean nextAction_arg2 = _nextAction_arg2;
		boolean nextAction_arg3 = _nextAction_arg3;

		Playable actor = getActor();
		if(nextAction == null || actor.isActionsDisabled())
			return false;

		Skill skill;
		Creature target;
		GameObject object;

		switch(nextAction)
		{
			case ATTACK:
				if(nextAction_arg0 == null)
					return false;
				target = (Creature) nextAction_arg0;
				_forceUse = nextAction_arg2;
				_dontMove = nextAction_arg3;
				clearNextAction();
				setIntention(AI_INTENTION_ATTACK, target);
				break;
			case CAST:
				if(nextAction_arg0 == null || nextAction_arg1 == null)
					return false;
				skill = (Skill) nextAction_arg0;
				target = (Creature) nextAction_arg1;
				_forceUse = nextAction_arg2;
				_dontMove = nextAction_arg3;
				clearNextAction();
				if(!skill.checkCondition(actor, target, _forceUse, _dontMove, true))
				{
					if(skill.getNextAction() == NextAction.ATTACK && !actor.equals(target))
					{
						setNextAction(PlayableAI.nextAction.ATTACK, target, null, _forceUse, false);
						return setNextIntention();
					}
					return false;
				}
				setIntention(AI_INTENTION_CAST, skill, target);
				break;
			case MOVE:
				if(nextAction_arg0 == null || nextAction_arg1 == null)
					return false;
				Location loc = (Location) nextAction_arg0;
				Integer offset = (Integer) nextAction_arg1;
				clearNextAction();
				actor.moveToLocation(loc, offset, nextAction_arg2);
				break;
			case REST:
				actor.sitDown(null);
				break;
			case INTERACT:
				if(nextAction_arg0 == null)
					return false;
				object = (GameObject) nextAction_arg0;
				clearNextAction();
				onIntentionInteract(object);
				break;
			case PICKUP:
				if(nextAction_arg0 == null)
					return false;
				object = (GameObject) nextAction_arg0;
				clearNextAction();
				onIntentionPickUp(object);
				break;
			case COUPLE_ACTION:
				if(nextAction_arg0 == null || nextAction_arg1 == null)
					return false;
				target = (Creature)nextAction_arg0;
				Integer socialId = (Integer)nextAction_arg1;
				_forceUse = nextAction_arg2;
				_nextAction = null;
				clearNextAction();
				onIntentionCoupleAction((Player)target, socialId);
				break;
			default:
				return false;
		}
		return true;
	}

	@Override
	public void clearNextAction()
	{
		_nextAction = null;
		_nextAction_arg0 = null;
		_nextAction_arg1 = null;
		_nextAction_arg2 = false;
		_nextAction_arg3 = false;
	}

	@Override
	protected void onEvtFinishCasting()
	{
		if(!setNextIntention())
			setIntention(AI_INTENTION_ACTIVE);
	}

	@Override
	protected void onEvtReadyToAct()
	{
		if(!setNextIntention())
			onEvtThink();
	}

	@Override
	protected void onEvtArrived()
	{
		if(!setNextIntention())
			if(getIntention() == AI_INTENTION_INTERACT || getIntention() == AI_INTENTION_PICK_UP)
				onEvtThink();
			else
				changeIntention(AI_INTENTION_ACTIVE, null, null);
	}

	@Override
	protected void onEvtArrivedTarget()
	{
		switch(getIntention())
		{
			case AI_INTENTION_ATTACK:
				thinkAttack(false);
				break;
			case AI_INTENTION_CAST:
				thinkCast(false);
				break;
			case AI_INTENTION_FOLLOW:
				thinkFollow();
				break;
			default:
				onEvtThink();
				break;
		}
	}

	@Override
	protected final void onEvtThink()
	{
		Playable actor = getActor();
		if(actor.isActionsDisabled())
			return;

		try
		{
			if(thinking++ > 1)
				return;

			switch(getIntention())
			{
				case AI_INTENTION_ACTIVE:
					thinkActive();
					break;
				case AI_INTENTION_ATTACK:
					thinkAttack(true);
					break;
				case AI_INTENTION_CAST:
					thinkCast(true);
					break;
				case AI_INTENTION_PICK_UP:
					thinkPickUp();
					break;
				case AI_INTENTION_INTERACT:
					thinkInteract();
					break;
				case AI_INTENTION_FOLLOW:
					thinkFollow();
					break;
				case AI_INTENTION_COUPLE_ACTION:
					thinkCoupleAction((Player)_intention_arg0, (Integer)_intention_arg1, false);
					break;
			}
		}
		catch(Exception e)
		{
			_log.error("", e);
		}
		finally
		{
			thinking--;
		}
	}

	protected void thinkActive()
	{

	}

	protected void thinkFollow()
	{
		Playable actor = getActor();

		Creature target = (Creature) _intention_arg0;
		Integer offset = (Integer) _intention_arg1;

		//Находимся слишком далеко цели, либо цель не пригодна для следования
		if(target == null || target.isAlikeDead() || actor.getDistance(target) > 4000 || offset == null)
		{
			clientActionFailed();
			return;
		}

		//Уже следуем за этой целью
		if(actor.isFollow && actor.getFollowTarget() == target)
		{
			clientActionFailed();
			return;
		}

		//Находимся достаточно близко или не можем двигаться - побежим потом ?
		if(actor.isInRange(target, offset + 20) || actor.isMovementDisabled())
			clientActionFailed();

		if(_followTask != null)
		{
			_followTask.cancel(false);
			_followTask = null;
		}

		_followTask = ThreadPoolManager.getInstance().schedule(new ThinkFollow(), 250L);
	}

	protected class ThinkFollow extends RunnableImpl
	{
		@Override
		public void runImpl()// throws Exception
		{
			Playable actor = getActor();

			if(getIntention() != AI_INTENTION_FOLLOW)
			{
				// Если пет прекратил преследование, меняем статус, чтобы не пришлось щелкать на кнопку следования 2 раза.
				if((actor.isPet() || actor.isSummon()) && getIntention() == AI_INTENTION_ACTIVE)
					((Summon) actor).setFollowMode(false);
				return;
			}

			Creature target = (Creature) _intention_arg0;
			int offset = _intention_arg1 instanceof Integer ? (Integer) _intention_arg1 : 0;

			if(target == null || target.isAlikeDead() || actor.getDistance(target) > 4000)
			{
				setIntention(CtrlIntention.AI_INTENTION_ACTIVE);
				return;
			}

			Player player = actor.getPlayer();
			if(player == null || player.isLogoutStarted() || (actor.isPet() || actor.isSummon()) && player.getPet() != actor)
			{
				setIntention(CtrlIntention.AI_INTENTION_ACTIVE);
				return;
			}

			if(!actor.isInRange(target, offset + 20) && (!actor.isFollow || actor.getFollowTarget() != target))
				actor.followToCharacter(target, offset, false);
			_followTask = ThreadPoolManager.getInstance().schedule(this, 250L);
		}
	}

	protected class ExecuteFollow extends RunnableImpl
	{
		private Creature _target;
		private int _range;

		public ExecuteFollow(Creature target, int range)
		{
			_target = target;
			_range = range;
		}

		@Override
		public void runImpl()
		{
			if(_target.isDoor())
				_actor.moveToLocation(_target.getLoc(), 40, true);
			else
				_actor.followToCharacter(_target, _range, true);
		}
	}

	@Override
	protected void onIntentionInteract(GameObject object)
	{
		Playable actor = getActor();

		if(actor.isActionsDisabled())
		{
			setNextAction(nextAction.INTERACT, object, null, false, false);
			clientActionFailed();
			return;
		}

		clearNextAction();
		changeIntention(AI_INTENTION_INTERACT, object, null);
		onEvtThink();
	}

	@Override
	protected void onIntentionCoupleAction(Player player, Integer socialId)
	{
		clearNextAction();
		changeIntention(CtrlIntention.AI_INTENTION_COUPLE_ACTION, player, socialId);
		onEvtThink();
	}

	protected void thinkInteract()
	{
		Playable actor = getActor();

		GameObject target = (GameObject) _intention_arg0;

		if(target == null)
		{
			setIntention(AI_INTENTION_ACTIVE);
			return;
		}

		int range = (int) (Math.max(30, actor.getMinDistance(target)) + 20);

		if(actor.isInRangeZ(target, range))
		{
			if(actor.isPlayer())
				((Player) actor).doInteract(target);
			setIntention(AI_INTENTION_ACTIVE);
		}
		else
		{
			actor.moveToLocation(target.getLoc(), 40, true);
			setNextAction(nextAction.INTERACT, target, null, false, false);
		}
	}

	@Override
	protected void onIntentionPickUp(GameObject object)
	{
		Playable actor = getActor();

		if(actor.isActionsDisabled())
		{
			setNextAction(nextAction.PICKUP, object, null, false, false);
			clientActionFailed();
			return;
		}

		clearNextAction();
		changeIntention(AI_INTENTION_PICK_UP, object, null);
		onEvtThink();
	}

	protected void thinkPickUp()
	{
		final Playable actor = getActor();

		final GameObject target = (GameObject) _intention_arg0;

		if(target == null)
		{
			setIntention(AI_INTENTION_ACTIVE);
			return;
		}

		if(actor.isInRange(target, 30) && Math.abs(actor.getZ() - target.getZ()) < 50)
		{
			if(actor.isPlayer() || actor.isPet())
				actor.doPickupItem(target);
			setIntention(AI_INTENTION_ACTIVE);
		}
		else
			ThreadPoolManager.getInstance().execute(new RunnableImpl()
			{
				@Override
				public void runImpl()
				{
					actor.moveToLocation(target.getLoc(), 10, true);
					setNextAction(nextAction.PICKUP, target, null, false, false);
				}
			});
	}

	protected void thinkAttack(boolean checkRange)
	{
		Playable actor = getActor();

		Player player = actor.getPlayer();
		if(player == null)
		{
			setIntention(AI_INTENTION_ACTIVE);
			return;
		}

		if(actor.isActionsDisabled() || actor.isAttackingDisabled())
		{
			actor.sendActionFailed();
			return;
		}

		boolean isPosessed = actor instanceof Summon && ((Summon) actor).isDepressed();

		Creature attack_target = getAttackTarget();
		if(attack_target == null || attack_target.isDead() || !isPosessed && !(_forceUse ? attack_target.isAttackable(actor) : attack_target.isAutoAttackable(actor)))
		{
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
			return;
		}
		
		if(!checkRange)
		{
			clientStopMoving();
			actor.doAttack(attack_target);
			return;
		}

		int range = actor.getPhysicalAttackRange();
		if(range < 10)
			range = 10;

		boolean canSee = GeoEngine.canSeeTarget(actor, attack_target, false);

		if(!canSee && (range > 200 || Math.abs(actor.getZ() - attack_target.getZ()) > 200))
		{
			actor.sendPacket(SystemMsg.CANNOT_SEE_TARGET);
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
			return;
		}

		range += actor.getMinDistance(attack_target);

		if(actor.isFakeDeath())
			actor.breakFakeDeath();

		if(actor.isInRangeZ(attack_target, range))
		{
			if(!canSee)
			{
				actor.sendPacket(SystemMsg.CANNOT_SEE_TARGET);
				setIntention(AI_INTENTION_ACTIVE);
				actor.sendActionFailed();
				return;
			}

			clientStopMoving(false);
			actor.doAttack(attack_target);
		}
		else if(!_dontMove)
			ThreadPoolManager.getInstance().execute(new ExecuteFollow(attack_target, range - 20));
		else
			actor.sendActionFailed();
	}

	protected void thinkCast(boolean checkRange)
	{
		Playable actor = getActor();

		Creature target = getAttackTarget();

		if(_skill.getSkillType() == SkillType.CRAFT || _skill.isToggle())
		{
			if(_skill.checkCondition(actor, target, _forceUse, _dontMove, true))
				actor.doCast(_skill, target, _forceUse);
			return;
		}

		if(target == null || target.isDead() != _skill.getCorpse() && !_skill.isNotTargetAoE())
		{
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
			return;
		}

		if(!checkRange)
		{
			// Если скилл имеет следующее действие, назначим это действие после окончания действия скилла
			if(_skill.getNextAction() == NextAction.ATTACK && !actor.equals(target))
				setNextAction(nextAction.ATTACK, target, null, _forceUse, false);
			else
				clearNextAction();

			clientStopMoving();

			if(_skill.checkCondition(actor, target, _forceUse, _dontMove, true))
				actor.doCast(_skill, target, _forceUse);
			else
			{
				setNextIntention();
				if(getIntention() == CtrlIntention.AI_INTENTION_ATTACK)
					thinkAttack(true);
			}

			return;
		}

		int range = actor.getMagicalAttackRange(_skill);
		if(range < 10)
			range = 10;

		boolean canSee = _skill.getSkillType() == SkillType.TAKECASTLE || _skill.getSkillType() == SkillType.TAKEFORTRESS || GeoEngine.canSeeTarget(actor, target, actor.isFlying());
		boolean noRangeSkill = _skill.getCastRange() == 32767;

		if(!noRangeSkill && !canSee && (range > 200 || Math.abs(actor.getZ() - target.getZ()) > 200))
		{
			actor.sendPacket(SystemMsg.CANNOT_SEE_TARGET);
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
			return;
		}

		range += actor.getMinDistance(target);

		if(actor.isFakeDeath())
			actor.breakFakeDeath();

		if(actor.isInRangeZ(target, range) || noRangeSkill)
		{
			if(!noRangeSkill && !canSee)
			{
				actor.sendPacket(SystemMsg.CANNOT_SEE_TARGET);
				setIntention(AI_INTENTION_ACTIVE);
				actor.sendActionFailed();
				return;
			}

			// Если скилл имеет следующее действие, назначим это действие после окончания действия скилла
			if(_skill.getNextAction() == NextAction.ATTACK && !actor.equals(target))
				setNextAction(nextAction.ATTACK, target, null, _forceUse, false);
			else
				clearNextAction();

			if(_skill.checkCondition(actor, target, _forceUse, _dontMove, true))
			{
				clientStopMoving(false);
				actor.doCast(_skill, target, _forceUse);
			}
			else
			{
				setNextIntention();
				if(getIntention() == CtrlIntention.AI_INTENTION_ATTACK)
					thinkAttack(true);
			}
		}
		else if(!_dontMove)
			ThreadPoolManager.getInstance().execute(new ExecuteFollow(target, range - 20));
		else
		{
			actor.sendPacket(Msg.YOUR_TARGET_IS_OUT_OF_RANGE);
			setIntention(AI_INTENTION_ACTIVE);
			actor.sendActionFailed();
		}
	}

	protected void thinkCoupleAction(Player target, Integer socialId, boolean cancel)
	{
		//
	}

	@Override
	protected void onEvtDead(Creature killer)
	{
		clearNextAction();
		super.onEvtDead(killer);
	}

	@Override
	protected void onEvtFakeDeath()
	{
		clearNextAction();
		super.onEvtFakeDeath();
	}

	public void lockTarget(Creature target)
	{
		Playable actor = getActor();

		if(target == null || target.isDead())
			actor.setAggressionTarget(null);
		else if(actor.getAggressionTarget() == null)
		{
			GameObject actorStoredTarget = actor.getTarget();
			actor.setAggressionTarget(target);
			actor.setTarget(target);

			clearNextAction();
			// DS: агрессия только перекидывает видимую цель, но не обрывает текущую атаку/каст
			/*if (getIntention() == CtrlIntention.AI_INTENTION_ATTACK)
				setAttackTarget(target);
			switch(getIntention())
			{
				case AI_INTENTION_ATTACK:
					setAttackTarget(target);
					break;
				case AI_INTENTION_CAST:
					L2Skill skill = actor.getCastingSkill();
					if(skill == null)
						skill = _skill;
					if(skill != null && !skill.isUsingWhileCasting())
						switch(skill.getTargetType())
						{
							case TARGET_ONE:
							case TARGET_AREA:
							case TARGET_MULTIFACE:
							case TARGET_TUNNEL:
								setAttackTarget(target);
								actor.setCastingTarget(target);
								break;
						}
					break;
			}*/

			if(actorStoredTarget != target)
				actor.sendPacket(new MyTargetSelected(target.getObjectId(), 0));
		}
	}

	@Override
	public void Attack(GameObject target, boolean forceUse, boolean dontMove)
	{
		Playable actor = getActor();

		if(target.isCreature() && (actor.isActionsDisabled() || actor.isAttackingDisabled()))
		{
			// Если не можем атаковать, то атаковать позже
			setNextAction(nextAction.ATTACK, target, null, forceUse, false);
			actor.sendActionFailed();
			return;
		}

		_dontMove = dontMove;
		_forceUse = forceUse;
		clearNextAction();
		setIntention(AI_INTENTION_ATTACK, target);
	}

	@Override
	public void Cast(Skill skill, Creature target, boolean forceUse, boolean dontMove)
	{
		Playable actor = getActor();

		// Если скилл альтернативного типа (например, бутылка на хп),
		// то он может использоваться во время каста других скиллов, или во время атаки, или на бегу.
		// Поэтому пропускаем дополнительные проверки.
		if(skill.altUse() || skill.isToggle())
		{
			if((skill.isToggle() || skill.isHandler()) && (actor.isOutOfControl() || actor.isStunned() || actor.isSleeping() || actor.isParalyzed() || actor.isAlikeDead()))
				clientActionFailed();
			else
				actor.altUseSkill(skill, target);
			return;
		}

		// Если не можем кастовать, то использовать скилл позже
		if(actor.isActionsDisabled())
		{
			//if(!actor.isSkillDisabled(skill.getId()))
			setNextAction(nextAction.CAST, skill, target, forceUse, dontMove);
			clientActionFailed();
			return;
		}

		//_actor.stopMove(null);
		_forceUse = forceUse;
		_dontMove = dontMove;
		clearNextAction();
		setIntention(CtrlIntention.AI_INTENTION_CAST, skill, target);
	}

	@Override
	public Playable getActor()
	{
		return (Playable) super.getActor();
	}
}
</C:\l2sq\Pac Project\Java\l2ft\gameserver\ai\PlayableAI.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Effect.java>
package l2ft.gameserver.model;

import l2ft.commons.threading.RunnableImpl;
import l2ft.gameserver.model.Skill;
import l2ft.gameserver.skills.EffectType;
import l2ft.gameserver.skills.effects.EffectTemplate;
import l2ft.gameserver.stats.Env;
import l2ft.gameserver.stats.funcs.Func;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Minimized Effect class for MVP.
 * - Manages a skill effect's start, duration, in-use state, and finishing.
 * - Omits advanced concurrency, scheduled tasks manager, stack scheduling, reflection, etc.
 */
public abstract class Effect extends RunnableImpl implements Comparable<Effect>
{
    private static final Logger _log = LoggerFactory.getLogger(Effect.class);

    protected final Creature _effector; // Caster
    protected final Creature _effected; // Target
    protected final Skill     _skill;
    protected final EffectTemplate _template;

    private boolean _inUse;    // True if effect is actively applying its stats (start->end)
    private boolean _active;   // True if effect is in "onStart/onActionTime" period
    private long    _startTime; // For basic time tracking
    private int     _count;    // Ticks count
    private long    _period;   // Single tick period (ms)
    private boolean _finished; // Whether effect finished

    public Effect(Env env, EffectTemplate template)
    {
        _effector  = env.character;
        _effected  = env.target;
        _skill     = env.skill;
        _template  = template;
        _count     = template.getCount();
        _period    = template.getPeriod();
    }

    /**
     * Called to check if the effect can be applied at all, e.g. conditions.
     */
    public boolean checkCondition()
    {
        return true;
    }

    /**
     * Schedules the effect onto the target's EffectList if conditions pass.
     */
    public final void schedule()
    {
        if (checkCondition())
            _effected.getEffectList().addEffect(this);
    }

    /**
     * Called once when the effect truly starts applying.
     */
    protected void onStart()
    {
        _active = true;
        getEffected().addStatFuncs(getStatFuncs());
        // If there's a special abnormal effect, apply it
        if (_template._abnormalEffect != null && _template._abnormalEffect.isVisible())
            getEffected().startAbnormalEffect(_template._abnormalEffect);
    }

    /**
     * Called each "tick" (or every action time) if the effect has ongoing behavior.
     * @return true if effect should continue, false if it should end now.
     */
    protected abstract boolean onActionTime();

    /**
     * Called when the effect ends or is canceled, to remove changes from the effect.
     */
    protected void onExit()
    {
        getEffected().removeStatsOwner(this);
        if (_template._abnormalEffect != null && _template._abnormalEffect.isVisible())
            getEffected().stopAbnormalEffect(_template._abnormalEffect);
        _active = false;
    }

    /**
     * Called by the EffectList or internally to forcibly stop the effect.
     */
    public final void exit()
    {
        if (!_finished)
        {
            _inUse = false;
            onExit();
            _effected.getEffectList().removeEffect(this);
            _finished = true;
        }
    }

    /**
     * Called by EffectList to say "start up this effect's logic now."
     */
    public final void start()
    {
        _startTime = System.currentTimeMillis();
        _inUse = true;
        onStart();
        // If a one-time effect or zero period, finalize quickly
        if (_period == 0)
        {
            onActionTime(); // one-shot
            exit();
        }
    }

    /**
     * Called periodically by whichever system is ticking effects. 
     * If time is up or onActionTime() says "stop," then effect ends.
     */
    public void tick()
    {
        if (_finished || !_active)
            return;

        if (_count > 0)
        {
            // If onActionTime returns false => end now
            if (!onActionTime())
            {
                exit();
                return;
            }
            _count--;
        }

        if (_count <= 0)
            exit();
    }

    public boolean isInUse()       { return _inUse; }
    public boolean isActive()      { return _active; }
    public boolean isFinished()    { return _finished; }

    public int getCount()          { return _count; }
    public long getPeriod()        { return _period; }
    public Skill getSkill()        { return _skill; }
    public EffectTemplate getTemplate() { return _template; }
    public Creature getEffector()  { return _effector; }
    public Creature getEffected()  { return _effected; }
    public EffectType getEffectType() { return _template._effectType; }

    /** Called to produce stat changes. */
    public Func[] getStatFuncs()
    {
        return getTemplate().getStatFuncs(this);
    }

    @Override
    public int compareTo(Effect o)
    {
        // Basic ordering not strictly used in the MVP
        return 0;
    }

    /** This is a placeholder for advanced concurrency from RunnableImpl. */
    @Override
    public void runImpl() throws Exception { }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\model\Effect.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmEngine.java>
package l2ft.gameserver.autofarm;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import l2ft.gameserver.ThreadPoolManager;
import l2ft.gameserver.model.Player;

/**
 * AutoFarmEngine is the central manager of auto-farming.
 * It keeps track of which players are actively auto-farming
 * and starts/stops their tasks.
 */
public final class AutoFarmEngine
{
    // Singleton pattern
    private static final AutoFarmEngine _instance = new AutoFarmEngine();

    // A map of player objectId -> AutoFarmState for all currently running sessions
    private final Map<Integer, AutoFarmState> _activeFarms = new ConcurrentHashMap<>();

    // A hidden constructor to ensure singleton
    private AutoFarmEngine()
    {
    }

    /**
     * Retrieves the global singleton instance of AutoFarmEngine.
     */
    public static AutoFarmEngine getInstance()
    {
        return _instance;
    }

    /**
     * Retrieves or creates an AutoFarmState for the specified player.
     */
    public AutoFarmState getOrCreateState(Player player)
    {
        if (player == null)
            return null;

        // If the state is already present, return it
        AutoFarmState st = _activeFarms.get(player.getObjectId());
        if (st == null)
        {
            st = new AutoFarmState(player);
            _activeFarms.put(player.getObjectId(), st);
            player.setAutoFarmState(st); // also store it in the Player
        }
        return st;
    }

    /**
     * For direct usage if you already have the objectId.
     */
    public AutoFarmState getAutoFarmState(int objectId)
    {
        return _activeFarms.get(objectId);
    }

    /**
     * Simplified method to see if this player is currently auto-farming.
     */
    public boolean isAutoFarming(Player player)
    {
        if (player == null)
            return false;

        AutoFarmState st = getAutoFarmState(player.getObjectId());
        return st != null && st.isActive();
    }

    /**
     * Start auto-farm for this player, if not already active.
     */
    public void startAutoFarm(Player player)
    {
        if (player == null)
            return;

        AutoFarmState st = getOrCreateState(player);
        if (!st.isActive())
        {
            st.setActive(true);
            scheduleTask(st);
            player.sendMessage("AutoFarm started.");
        }
        else
        {
            player.sendMessage("AutoFarm is already active.");
        }
    }

    /**
     * Stop auto-farm for the player, if currently active.
     */
    public void stopAutoFarm(Player player)
    {
        if (player == null)
            return;

        AutoFarmState st = _activeFarms.get(player.getObjectId());
        if (st != null && st.isActive())
        {
            st.setActive(false);
            st.cancelTask();
            player.sendMessage("AutoFarm stopped.");
        }
        else
        {
            player.sendMessage("AutoFarm is not running.");
        }
    }

    /**
     * Schedules the repeating auto-farm logic via the ThreadPoolManager.
     */
    private void scheduleTask(AutoFarmState farmState)
    {
        // If there's already a task scheduled, cancel first
        farmState.cancelTask();

        // Create a new repeating task
        // We poll the config for intervals, or default to 1000ms
        long delayMs = AutoFarmConfig.UPDATE_INTERVAL_MS;
        farmState.setTask(ThreadPoolManager.getInstance().scheduleAtFixedRate(
            new AutoFarmTask(farmState),
            0L,
            delayMs
        ));
    }

    /**
     * (Optional) Called from World if you want to notify about new objects,
     * but minimal usage is commented out in your World.java
     */
    public void onObjectAdded(Object object)
    {
        // in a real scenario, we might:
        // check if it's a monster, see if any player's auto-farm needs it
    }

    /**
     * Called on server shutdown or reload to safely remove all references.
     */
    public void shutdownAll()
    {
        for (AutoFarmState st : _activeFarms.values())
        {
            st.setActive(false);
            st.cancelTask();
        }
        _activeFarms.clear();
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmEngine.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmTask.java>
package l2ft.gameserver.autofarm;

import l2ft.gameserver.model.Creature;
import l2ft.gameserver.model.GameObject;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.World;
import l2ft.gameserver.model.instances.MonsterInstance;

/**
 * A repeated task that runs the actual auto-farming logic for a single player.
 * This is scheduled by the AutoFarmEngine.
 */
public class AutoFarmTask implements Runnable
{
    private final AutoFarmState _farmState;

    public AutoFarmTask(AutoFarmState farmState)
    {
        _farmState = farmState;
    }

    @Override
    public void run()
    {
        // If state or references are invalid, stop
        if (_farmState == null || !_farmState.isActive())
            return;

        Player player = _farmState.getPlayer();
        if (player == null || player.isLogoutStarted() || player.isDead())
        {
            // Mark inactive if player is offline or dead
            _farmState.setActive(false);
            _farmState.cancelTask();
            return;
        }

        // Basic logic:
        // 1) Check if we have a valid target
        Creature target = validateTarget();
        if (target == null)
        {
            // 2) If we do not, try to find a new monster
            target = findTarget();
            if (target != null)
            {
                player.setTarget(target);
                // optionally, broadcast selection
            }
        }

        // 3) If we have a valid monster, attempt to attack
        if (target != null && !target.isDead())
        {
            // If in range, do attack. Otherwise, move to it
            double dist = player.getDistance(target);
            if (dist < 100.0)
            {
                // Attack it
                player.doAttack(target);
            }
            else
            {
                // Move closer (Creature supports moveToLocation(x,y,z,offset))
                player.moveToLocation(target.getLoc().x, target.getLoc().y, target.getLoc().z, 40);
            }
        }
        // We can optionally do more advanced logic
        // like picking up items, using skills, etc.
    }

    /**
     * Ensures the current target is still valid for auto-farm.
     */
    private Creature validateTarget()
    {
        Player player = _farmState.getPlayer();
        if (player == null)
            return null;

        GameObject currentTarget = player.getTarget();
        if (currentTarget == null || !currentTarget.isCreature())
            return null;

        Creature creature = (Creature) currentTarget;
        if (creature.isDead())
            return null;

        if (!currentTarget.isMonster())
            return null;

        // cast
        MonsterInstance monster = (MonsterInstance) creature;
        // Check if it is auto-attackable
        if (!monster.isAutoAttackable(player))
            return null;

        return monster;
    }

    /**
     * A simple finder that picks the closest monster in range.
     */
    private Creature findTarget()
    {
        Player player = _farmState.getPlayer();
        if (player == null)
            return null;

        int searchRange = AutoFarmConfig.SEARCH_RADIUS;
        Creature best = null;
        double closestDist = Double.MAX_VALUE;

        for (Creature c : World.getAroundCharacters(player))
        {
            if (c.isMonster() && !c.isDead())
            {
                double dist = player.getDistance(c);
                if (dist < searchRange && dist < closestDist)
                {
                    closestDist = dist;
                    best = c;
                }
            }
        }
        return best;
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmTask.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmConfig.java>
package l2ft.gameserver.autofarm;

/**
 * Holds configurable settings for auto-farm logic.
 * For this MVP, we'll keep them as static fields.
 * In a real scenario, you might read from a config file or DB.
 */
public final class AutoFarmConfig
{
    // Whether autofarm is globally enabled
    public static boolean ENABLE_AUTO_FARM = true;

    // Interval between each auto-farm cycle in milliseconds
    public static long UPDATE_INTERVAL_MS = 1000L;

    // Range within which we look for monsters
    public static int SEARCH_RADIUS = 700;

    private AutoFarmConfig()
    {
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmConfig.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmState.java>
package l2ft.gameserver.autofarm;

import java.util.concurrent.ScheduledFuture;

import l2ft.gameserver.model.Player;

/**
 * Holds per-player state for auto-farming, such as:
 * - whether it's active
 * - the scheduled task reference
 * - references to targeting or skill usage
 */
public class AutoFarmState
{
    private final Player _player; // reference to the player
    private boolean _active;      // is auto-farm on
    private ScheduledFuture<?> _task; // the repeating task

    public AutoFarmState(Player player)
    {
        _player = player;
        _active = false;
    }

    public Player getPlayer()
    {
        return _player;
    }

    public boolean isActive()
    {
        return _active;
    }

    public void setActive(boolean active)
    {
        _active = active;
    }

    public void setTask(ScheduledFuture<?> task)
    {
        _task = task;
    }

    /**
     * Cancels any existing scheduled task, if present.
     */
    public void cancelTask()
    {
        if (_task != null)
        {
            _task.cancel(false);
            _task = null;
        }
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmState.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmUIHandler.java>
package l2ft.gameserver.autofarm;

import l2ft.gameserver.handler.bypass.IBypassHandler;
import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.instances.NpcInstance;
import l2ft.gameserver.network.l2.s2c.NpcHtmlMessage;

/**
 * Handles community board or NPC bypass commands for the autofarm feature.
 * Implementation to match the IBypassHandler interface.
 */
public class AutoFarmUIHandler implements IBypassHandler {
    private static final String[] COMMAND_LIST = { "autofarm_start", "autofarm_stop", "autofarm_refresh" };

    @Override
    public String[] getBypasses() {
        return COMMAND_LIST;
    }

    @Override
    public void onBypassFeedback(NpcInstance npc, Player player, String command) {
        if (player == null)
            return;

        // Example parse: "autofarm_start" or "autofarm_stop" or "autofarm_refresh"
        if (command.equals("autofarm_start")) {
            AutoFarmEngine.getInstance().startAutoFarm(player);
            showStatusPage(player);
        } else if (command.equals("autofarm_stop")) {
            AutoFarmEngine.getInstance().stopAutoFarm(player);
            showStatusPage(player);
        } else if (command.equals("autofarm_refresh")) {
            // Just re-show the page
            showStatusPage(player);
        }
    }

    /**
     * Display a simple HTML status page referencing main.htm
     */
    private void showStatusPage(Player player) {
        if (player == null)
            return;

        // main.htm is your HTML file from the pile
        NpcHtmlMessage html = new NpcHtmlMessage(5);
        html.setFile("data/html/scripts/services/community/autofarm/main.htm");

        boolean isRunning = AutoFarmEngine.getInstance().isAutoFarming(player);

        // For the %time% placeholder
        String timeLeft = "N/A"; // example placeholder
        html.replace("%time%", timeLeft);

        // For the %state% placeholder
        String advancedState = isRunning
                ? "<td align=center><font name=hs12 color=\"63FF63\">Running</font></td><td align=center><button value=\"Stop\" action=\"bypass autofarm_stop\" width=70 height=22 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td>"
                : "<td align=center><button value=\"Start\" action=\"bypass autofarm_start\" width=70 height=22 back=\"L2UI_ct1.button_df\" fore=\"L2UI_ct1.button_df\"></td><td align=center><font name=hs12 color=\"FF6363\">Stopped</font></td>";

        html.replace("%state%", advancedState);

        player.sendPacket(html);
    }
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\autofarm\AutoFarmUIHandler.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\BypassHandler.java>
package l2ft.gameserver.handler.bypass;

/**
 * @author VISTALL
 * @date 15:51/12.07.2011
 */
public class BypassHandler {
	private static final BypassHandler _instance = new BypassHandler();

	public static BypassHandler getInstance() {
		return _instance;
	}

	public void registerBypass(IBypassHandler bypass) {

	}
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\BypassHandler.java>
<C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\IBypassHandler.java>
package l2ft.gameserver.handler.bypass;

import l2ft.gameserver.model.Player;
import l2ft.gameserver.model.instances.NpcInstance;

/**
 * @author VISTALL
 * @date 15:54/12.07.2011
 */
public interface IBypassHandler
{
	String[] getBypasses();

	void onBypassFeedback(NpcInstance npc, Player player, String command);
}

</C:\l2sq\Pac Project\Java\l2ft\gameserver\handler\bypass\IBypassHandler.java>
</Pile Files>


</The Pile>
</previous prompt, containing an updated pile>
</previous prompt>